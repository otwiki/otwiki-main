<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Monge Problem – OT WIKI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">OT WIKI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Monge Problem</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>The optimal transport problem first came up in the 18th century, brought by <a href="https://en.wikipedia.org/wiki/Gaspard_Monge">Gaspard Monge</a>. The original problem is called the <strong>Monge Problem</strong>, which wants to find an optimal way to rearrange the dirt dig out from the land into castle walls or other desired shapes. The “optimal way” means the way with the minimal “cost”, or workload. In the following, we will first formulate the Monge problem, then explain why it is a challenging problem. On top of that, we introduce the Kantorovich’s problem which is a generalized version of Monge problem but it perfectly tackles the challenges. Finally, we introduce Brenier’s theorem and discuss the solvability of these two problems.</p>
<section id="formulation-of-monge-problem" class="level2">
<h2 class="anchored" data-anchor-id="formulation-of-monge-problem">Formulation of Monge Problem</h2>
<p>To begin with, we use probability measures to represent the piles of dirt. Suppose <span class="math inline">\((X,d)\)</span> is a metric space that is equipped with a natural topology generated by all the open balls. The topology defines the collection of open sets, and we denote <span class="math inline">\(\mathcal{B}(X)\)</span> as the <span class="math inline">\(\sigma\)</span>-algebra generated by the open sets, which is called the Borel <span class="math inline">\(\sigma\)</span>-algebra on the metric space <span class="math inline">\((X,d)\)</span>. Denote <span class="math inline">\(\mathcal{M}(X)\)</span> as the set of all finite measures(a pile has finite amount of dirt!) defined on the measurable space <span class="math inline">\((X,\mathcal{B}(X))\)</span>. For a measure <span class="math inline">\(\mu\in\mathcal{M}(X)\)</span> and <span class="math inline">\(B\in\mathcal{B}(X)\)</span>, <span class="math inline">\(\mu(B)\)</span> represents how much dirt is contained in the set <span class="math inline">\(B\)</span>, so a measure can precisely characterize the shape of a dirt pile. When we rearrange the dirt pile, we keep the total amount unchanged, so without losing of generality we can assume the total mass <span class="math inline">\(\mu(X)=1\)</span>, meaning we restrict our attention to the set of all probability measures on <span class="math inline">\((X,\mathcal{B}(X))\)</span>, denoted by <span class="math inline">\(\mathcal{P}(X)\)</span>.</p>
<p>The next step is to define the behavior of “transport”. A possible way is to use the following notion of <em>transport map</em>.</p>
<p><strong>Definition 1.</strong> <em>Transport map</em></p>
<p>Give two probability measures <span class="math inline">\(\mu,\nu\in\mathcal{P}(X)\)</span>, a measurable function <span class="math inline">\(t:X\rightarrow X\)</span> <em>transports</em> <span class="math inline">\(\mu\)</span> onto <span class="math inline">\(\nu\)</span> if :<span class="math inline">\(\nu(B) = \mu(t^{-1}(B)),\ \forall \ B\in\mathcal{B}(X)\)</span> where <span class="math inline">\(t^{-1} = \{x\in X: t(x)\in B\}\)</span> is the preimage. We call <span class="math inline">\(\nu\)</span> the <em>push-forward measure</em> of <span class="math inline">\(\mu\)</span> under <span class="math inline">\(t\)</span>, denoted by <span class="math inline">\(\nu = t_\# \mu\)</span> or <span class="math inline">\(\nu = \mu\circ t^{-1}\)</span>.</p>
<p>The intuition of this definition is that a transport map <span class="math inline">\(t\)</span> moves all of the dirt at <span class="math inline">\(x\in X\)</span> to the location <span class="math inline">\(t(x)\)</span>. Now we can formulate the Monge problem mathematically.</p>
<p><strong>Definition 2.</strong> <em>Monge’s Problem</em></p>
<p>Given <span class="math inline">\(\mu,\nu\in\mathcal{P}(X)\)</span>, Monge problem is the following optimization problem. :<span class="math inline">\(\inf_{t} \int_{X}|t(x)-x|d\mu(x), \ s.t. \ t:X\rightarrow X \ \text{is measurable and  }t_{\#}\mu = \nu\)</span></p>
<p>To illustrate, <span class="math inline">\(|t(x)-x|\)</span> is the distance of moving the dirt from <span class="math inline">\(x\)</span> to <span class="math inline">\(t(x)\)</span>, and the integral <span class="math inline">\(\int_{X}|t(x)-x|d\mu(x)\)</span> is the total cost or effort. The condition <span class="math inline">\(t_{\#}\mu =\nu\)</span> ensures that <span class="math inline">\(t\)</span> is a transport map from <span class="math inline">\(\mu\)</span> onto <span class="math inline">\(\nu\)</span>, meaning <span class="math inline">\(t\)</span> rearranges the dirt in the shape of <span class="math inline">\(\mu\)</span> to look like that of <span class="math inline">\(\nu\)</span>. If <span class="math inline">\(t\)</span> solves the Monge problem, meaning it realized the infimum, then we call it an <em>optimal transport map</em>. Here, we use the cost function <span class="math inline">\(c(x^1,x^2)=|x^1-x^2|\)</span>, but it can also be replaced by other general cost functions. The problem can easily be generalized to the one regarding two different spaces <span class="math inline">\(X,Y\)</span>, with <span class="math inline">\(\mu\in\mathcal{P}(X)\)</span>, <span class="math inline">\(\nu\in\mathcal{P}(Y)\)</span> and <span class="math inline">\(c:X\times Y\rightarrow[0,\infty)\)</span> is the cost function, but it is essentially the same as the one regarding the same space.</p>
<p>The Monge problem is important because it provides us with spatial insight of how far two probability measures are. If two probability measures are “closed to each other”, there should be some transport map such that the total effort of transport is small. This idea leads to the concept of <a href="http://34.106.105.83/wiki/1-Wasserstein_metric_and_generalizations">Wasserstein metric</a>.</p>
</section>
<section id="challenges-of-monge-problem" class="level2">
<h2 class="anchored" data-anchor-id="challenges-of-monge-problem">Challenges of Monge Problem</h2>
<p>The Monge problem turns out to be a very challenging problem for several reasons as follows.</p>
<ul>
<li><strong>The constraint set can be empty</strong>. Given <span class="math inline">\(\mu,\nu\in\mathcal{P}(X)\)</span>, it does not necessarily exist a transport map from <span class="math inline">\(\mu\)</span> onto <span class="math inline">\(\nu\)</span>: <span class="math inline">\(t_{\#}\mu=\nu\)</span>. For example, consider <span class="math inline">\(\mu=\delta_{0}\)</span>, the point mass at <span class="math inline">\(0\)</span>, and <span class="math inline">\(\nu\)</span> is the uniform measure on <span class="math inline">\([0,1]\)</span>. For every measurable function <span class="math inline">\(t:X\rightarrow X\)</span>, <span class="math inline">\(t_{\#}\mu\)</span> should be a point mass at <span class="math inline">\(t(0)\)</span> so <span class="math inline">\(t\)</span> cannot yield a uniform distribution on <span class="math inline">\([0,1]\)</span>. The reason is that a transport map cannot split the mass concentrated at one point<span class="math inline">\(---\)</span>it transports all the mass at point <span class="math inline">\(x\)</span> to the location <span class="math inline">\(t(x)\)</span>.</li>
</ul>
<p>*<strong>Solutions may not be unique</strong>. Let <span class="math inline">\(\mu\)</span>, <span class="math inline">\(\nu\)</span> be the uniform distribution on <span class="math inline">\((0,1)\)</span> and <span class="math inline">\((1/4,5/4)\)</span> respectively. Consider the following two transport maps.</p>
<ol type="1">
<li><p>Transport all the mass on <span class="math inline">\((0,1/4)\)</span> to <span class="math inline">\((1,5/4)\)</span> and keep the rest unchanged. In this case, <span class="math inline">\(t_0(x) = x+1\)</span> for $ x(0,1/4)$ and <span class="math inline">\(t(x) = x\)</span> for $ x(1/4,1)$ is the transport map and the cost is <span class="math inline">\(\int|t_0(x)-x|d\mu(x) = \int_{0}^{1/4}1dx=1/4\)</span>.</p></li>
<li><p>Shift all the mass to the right by <span class="math inline">\(1/4\)</span>. In this case, <span class="math inline">\(t_1(x)=x+1/4\)</span> is the transport map and the cost is <span class="math inline">\(\int |t_1(x)-x|d\mu(x) = \int_{0}^{1}1/4 dx = 1/4\)</span>.</p></li>
</ol>
<p>It is not hard to imagine that other methods of transport will cause larger effort, so this problem has two different optimal solutions.</p>
<ul>
<li><p><strong>The constraint set is not convex</strong>. In general, for an optimization problem, we usually take an initial guess of the solution and perturb it to see if the objective function decreases. The convexity of constraint set guarantees that the point after perturbation is still in the constraint set. However, this is not always true for Monge problem. Consider the transport maps <span class="math inline">\(t_{0}\)</span> and <span class="math inline">\(t_1\)</span> defined in the last example. Their convex combination is : <span class="math display">\[t\_{\alpha}(x) = (1-\alpha)t\_{0}(x) + \alpha t\_{1}(x)=
\begin{cases}
(1-\alpha)(x+1/4) +\alpha(x+1), &amp;x\in (0,1/4);\\
(1-\alpha)(x+1/4) + \alpha x , &amp; x\in (1/4,1);
\end{cases}
\]</span> Take <span class="math inline">\(\alpha = 1/2\)</span>, we have : <span class="math display">\[t\_{1/2}(x) =
\begin{cases}
x+5/8, &amp;x\in (0,1/4);\\
x+1/8 , &amp; x\in (1/4,1);
\end{cases}
\]</span></p>
<p>Then <span class="math inline">\(\nu((5/8,3/4))= 1/8\)</span>, but <span class="math inline">\((t_{{1/2}\#}\mu)((5/8,3/4)) = \mu((0,1/8)\cup(1/2,5/8))=1/4\)</span>, so <span class="math inline">\(t_{1/2}\)</span> does not give a transport map from <span class="math inline">\(\mu\)</span> onto <span class="math inline">\(\nu\)</span> any more.</p></li>
</ul>
</section>
<section id="a-generalized-problem-kantorovichs-problem" class="level2">
<h2 class="anchored" data-anchor-id="a-generalized-problem-kantorovichs-problem">A generalized problem: Kantorovich’s Problem</h2>
<p>An approach to tackle the problems mentioned in Section II is to use a “transport plan” instead of a transport map. This gives a more generalized version of the problem called <a href="http://34.106.105.83/wiki/Kantorovich_Problem">Kantorovich Problem</a>.</p>
<p><strong>Definition 3.</strong> <em>Transport plan</em></p>
<p>Given <span class="math inline">\(\mu,\nu\in\mathcal{P}(X)\)</span>, a transport plan is a probability measure <span class="math inline">\(\gamma\in \mathcal{P}(X\times X)\)</span> on the product space <span class="math inline">\((X\times X,\mathcal{B}(X\times X))\)</span> such that <span class="math inline">\((\pi^{1})_{\#} \gamma = \mu\)</span>, <span class="math inline">\((\pi^{2})_{\#}\gamma = \nu\)</span>, where <span class="math inline">\(\pi^{i}:X\times X\rightarrow X\)</span>, <span class="math inline">\(\pi^{i}(x_1,x_2)=x_i\)</span>, <span class="math inline">\(i =1,2\)</span> are projection maps. The set of all transport plans from <span class="math inline">\(\mu\)</span> to <span class="math inline">\(\nu\)</span> is denoted by <span class="math inline">\(\Gamma(\mu,\nu)\)</span>.</p>
<p>The conditions <span class="math inline">\((\pi^{1})_{\#} \gamma = \mu\)</span>, <span class="math inline">\((\pi^{2})_{\#}\gamma = \nu\)</span> give the right marginals: :<math> (A) = ((^1)</math><em>#</em> )(A)= ((<sup>1)</sup>{-1}(A))=(AX),<br>
(B) = ((^2)# )(A)= ((<sup>2)</sup>{-1}(A))=(XB)  Therefore, a transport plan is a probability measure on the product space <span class="math inline">\(X\times X\)</span> that has marginals distributions <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\nu\)</span>. In addition, <span class="math inline">\(\gamma(A\times B)\)</span> represents the amount of mass taken from set <span class="math inline">\(A\)</span> that is sent to set <span class="math inline">\(B\)</span>. Since <span class="math inline">\(\gamma(A\times B)\leq \gamma(A\times X)=\mu(A)\)</span>, a transport plan can move only a fraction but not necessarily all of the mass at some place to other locations, and this solves the problem that a transport map cannot split a point mass. Moreover, any transport map can be represented as a transport plan: if <span class="math inline">\(t\)</span> is a transport map with <span class="math inline">\(t_{\#}\mu=\nu\)</span>, then <span class="math inline">\(\gamma\equiv(id\times t)_{\#}\mu\)</span> is a transport plan in <span class="math inline">\(\Gamma(\mu,\nu)\)</span>, where <span class="math inline">\(id\)</span> is the identity map.</p>
<p>Based on the notion of transport plans, we can state <em>Kantorovich’s problem</em>, which is a problem more general than Monge problem. Instead of optimizing the cost over all transport maps, it minimizes the cost over all transport plans.</p>
<p><strong>Definition 4.</strong> <em>Kantorovich’s problem</em></p>
<p>Given <span class="math inline">\(\mu,\nu\in\mathcal{P}(X)\)</span>, the following optimization problem is the <em>Kantorovich’s problem</em>: :<math> *{*\gamma: \gamma\in\Gamma(\mu,\nu)}\int{X\times X}|x</math><sup>{1}-x</sup>{2}|<sup>{p}d</sup>(x1,x^2), &nbsp;p </p>
<p>Denote the cost by <span class="math inline">\(\mathbb{K}_{p}(\gamma)\equiv \int_{X\times X}|x^1-x^2|d\gamma(x^1,x^2)\)</span>, which is a functional on <span class="math inline">\(\Gamma(\mu,\nu)\)</span>. If <span class="math inline">\(\gamma\)</span> attains the infimum, we call it an optimal transport plan. Here, we use the cost function <span class="math inline">\(c(x^1,x^2)=|x^1-x^2|^p\)</span>, but it can also be replaced by other general cost functions.</p>
<p>The Kantorovich’s problem is a better-behaved problem for the following reasons. * <strong>The constraint sets is always nonempty</strong>. For <span class="math inline">\(\mu,\nu\in\mathcal{P}(X)\)</span>, the product measure <span class="math inline">\(\mu\times \nu\)</span> is always a transport plan in <span class="math inline">\(\Gamma(\mu,\nu)\)</span>. * <strong>The constraint set is convex</strong>. Take <span class="math inline">\(\gamma_{0}\)</span>, <span class="math inline">\(\gamma_{1}\in\Gamma(\mu,\nu)\)</span>, the convex combination is <span class="math inline">\(\gamma_{\alpha} \equiv (1-\alpha)\gamma_{0}+ \alpha \gamma_{1} ,\ \alpha\in [0,1]\)</span>. Notice that it gives the right marginals: <span class="math inline">\((\pi^{1}_{\#}\gamma_{\alpha})(A)=\gamma_{\alpha}(A\times X)=(1-\alpha)\gamma_{0}(A\times X)+\alpha\gamma_{1}(A\times X)=(1-\alpha)\mu(A)+\alpha\mu(A)=\mu(A)\)</span>, and <span class="math inline">\((\pi^{2}_{\#}\gamma_{\alpha})(B)=\nu(B)\)</span> holds similarly.</p>
<ul>
<li><strong>The objective function is convex as well</strong>. Notice that <math> </math><em>{p}(</em>) = (1-)_{p}(*0)+*(_1) , so objective function is actually linear.</li>
<li><strong>Kantorovich’s problem has a <a href="http://34.106.105.83/wiki/Kantorovich_Dual_Problem_(for_general_costs)">dual problem</a></strong>.</li>
<li><strong>The minimizer exists</strong> via the direct method of the calculus of variations.</li>
</ul>
</section>
<section id="breniers-theorem-solvability-of-the-problem" class="level2">
<h2 class="anchored" data-anchor-id="breniers-theorem-solvability-of-the-problem">Brenier’s Theorem, Solvability of the problem</h2>
<p>In this section, we consider a special case where <span class="math inline">\(X=\mathbb{R}^d\)</span> and the cost function is quadratic: <span class="math inline">\(c(x^1,x^2)=|x^1-x^2|^2\)</span>. These assumptions allow us to obtain quite strong results for the solvability of Monge and Kantorovich’s problems, which is known as the following <em>Brenier’s theorem</em>.</p>
<p><strong>Theorem 1.</strong> <em>Brenier’s theorem</em></p>
<p>Given <span class="math inline">\(\mu,\nu\in\mathcal{P}_{2}(\mathbb{R}^d)\)</span>, <span class="math inline">\(\mu\ll\mathcal{L}^d\)</span>, where <span class="math inline">\(\mathcal{P}_{2}(\mathbb{R}^d)\equiv\{\mu\in\mathcal{P}(\mathbb{R}^{d}):\int |x|^2 d\mu(x)&lt;\infty\}\)</span> and <span class="math inline">\(\mathcal{L}^d\)</span> is the Lebesgue measure on <span class="math inline">\(\mathbb{R}^d\)</span>. Then there exists a unique optimal transport plan <span class="math inline">\(\gamma_{\star}\)</span> of the form <span class="math inline">\(\gamma_{\star} = (id \times t_{\star})_{\#}\mu\)</span> for the Kantorovich’s problem, where <span class="math inline">\(t_{\star}:\mathbb{R}^d\rightarrow\mathbb{R}^d\)</span> is a measurable function. Notice that <span class="math inline">\(t_{\star}\)</span> is actually a transport map from <span class="math inline">\(\mu\)</span> onto <span class="math inline">\(\nu\)</span>, so <span class="math inline">\(t_{\star}\)</span> solves the corresponding Monge problem. In particular, the optimal cost of two problems coincide: :<span class="math inline">\(\inf_{t:t_{\#}\mu=\nu}\mathbb{M}_{2}(t)=\inf_{\gamma\in\Gamma(\mu,\nu)}\mathbb{K}_{2}(\gamma)\)</span> where <span class="math inline">\(\mathbb{M}_{2}(t)\equiv \int |t(x)-x|^2 d\mu(x)\)</span>.</p>
<p>The proof of the result relies heavily on the duality property of the Kantorovich’s problem. By passing to the dual problem, we are able to give the expression of <span class="math inline">\(t\)</span> as the gradient of the Kantorovich potential<ref name="Santambrogio">. The assumption that <span class="math inline">\(\mu\)</span> is absolute continuous w.r.t Lebesgue measure can be weakened to not giving mass on sets of <span class="math inline">\(d-1\)</span> dimensional Hausdorff measure <ref name="Gigli inverse">, and the result still holds for cost functions in the form of <span class="math inline">\(c(x^1,x^2)=h(x^1-x^2)\)</span> for some convex function <span class="math inline">\(h\)</span>.</ref></ref></p>
</section>
<section id="reference" class="level2">
<h2 class="anchored" data-anchor-id="reference">Reference</h2>
<p><references></references></p>
<p><ref name="Santambrogio"><a href="https://link.springer.com/book/10.1007/978-3-319-20828-2">F. Santambrogio, <em>Optimal Transport for Applied Mathematicians</em>, p.&nbsp;54-57</a></ref></p>
<p><ref name="Gigli inverse"><a href="https://www.intlpress.com/site/pub/pages/journals/items/maa/content/vols/0018/0002/a001/">N.Gigli, <em>On the inverse implication of Brenier-Mccann theorems and the structure of</em> <span class="math inline">\((P_2(M),W_2)\)</span></a></ref></p>
<p></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/otwiki\.github\.io\/otwiki-main\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // default icon
          link.classList.add("external");
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>