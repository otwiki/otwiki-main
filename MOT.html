<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Haosheng Zhou, Xiang Fang">

<title>Applications of Optimal Transport and Martingale Optimal Transport in Mathematical Finance – OT WIKI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">OT WIKI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Applications of Optimal Transport and Martingale Optimal Transport in Mathematical Finance</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Haosheng Zhou, Xiang Fang </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>A central topic in mathematical finance is the pricing of financial derivatives—contracts that facilitate the exchange or allocation of resources across different time periods. We introduce the principle of arbitrage-free pricing in financial markets and focus on a fundamental class of financial derivatives known as options. Following the classical approach of model-based finance, we price options based on two different ideas: hedging and risk-neural pricing, which have essential underlying connections. Moving to an incomplete market, where the stock price dynamics are unknown, we motivate model-free finance, where the corresponding optimization problems for option pricing could be naturally interpreted in the context of optimal transport and martingale optimal transport.</p>
<section id="fundamentals-of-mathematical-finance" class="level1">
<h1>Fundamentals of Mathematical Finance</h1>
<p>We begin by restricting our discussions to the continuous-time setting, with the current time as <span class="math inline">\(0\)</span> by default. Assume the market includes a risk-free asset (e.g., a bond), which we refer to as <strong>cash</strong>, with a constant risk-free interest rate <span class="math inline">\(r\)</span>, i.e., <span class="math inline">\(1\)</span> dollor deterministically accumulates to <span class="math inline">\(e^{rt}\)</span> dollars in time <span class="math inline">\(t\)</span>. In addition, there exists a risky asset, which we refer to as <strong>stock</strong>, whose price at time <span class="math inline">\(t\)</span> is denoted by <span class="math inline">\(S_t\)</span>, a stochastic process on the filtered probability space <span class="math inline">\((\Omega,\{\mathscr{F_t}\}_{t\geq 0},\mathscr{F},\mathbb{P})\)</span>.</p>
<section id="arbitrage-free-pricing" class="level2">
<h2 class="anchored" data-anchor-id="arbitrage-free-pricing">Arbitrage-Free Pricing</h2>
<p>The fundamental principle of derivative pricing requires no arbitrage to exist in the market. Intuitively, arbitrage refers to the existence of a self-financing portfolio that requires no external endowment, yet guarantees a non-negative payoff almost surely, and yields a strictly positive profit with a positive probability. A mathematically rigorous definition of arbitrage relies on the notion of market viability, as discussed in <span class="citation" data-cites="karatzas2021portfolio">(<a href="#ref-karatzas2021portfolio" role="doc-biblioref">Karatzas and Kardaras 2021</a>)</span>. Nevertheless, the concept of no-arbitrage pricing can be illustrated through the following simple example.</p>
<p>Consider a forward contract currently signed, which obligates the holder to receive one unit of stock at a future time <span class="math inline">\(T\)</span> and to pay the forward price <span class="math inline">\(F(0,T)\)</span> at time <span class="math inline">\(T\)</span>. A self-financing arbitrage portfolio can be constructed as follows:</p>
<ol type="1">
<li><p>Enter the forward contract at time <span class="math inline">\(0\)</span>.</p></li>
<li><p>Sell <span class="math inline">\(1\)</span> unit of stock at time <span class="math inline">\(0\)</span>, receiving <span class="math inline">\(S_0\)</span> cash.</p></li>
<li><p>Pay the forward price <span class="math inline">\(F(0,T)\)</span> and receive <span class="math inline">\(1\)</span> unit of stock at time <span class="math inline">\(T\)</span>.</p></li>
</ol>
<p>Since the stock received at time <span class="math inline">\(T\)</span> exactly offsets the short position, this strategy gives a risk-free portfolio. The net cash flow (amount paid by the portfolio holder) at time <span class="math inline">\(T\)</span> is <span class="math inline">\(F(0,T)-S_0e^{rT}\)</span>, which shall be non-negative to prevent arbitrage, i.e., <span class="math inline">\(F(0,T)-S_0e^{rT}\geq 0\)</span>. Conversely, by reversing the strategy (buying the stock, shorting the forward contract), the no-arbitrage condition requires <span class="math inline">\(F(0,T)-S_0e^{rT}\leq 0\)</span>. Combining both inequalities yields the arbitrage-free price of the forward contract: <span class="math inline">\(F(0,T) = S_0e^{rT}\)</span>.</p>
<p>This example, though simple, illustrates the concept of <strong>hedging</strong>—reducing or eliminating risk by trading other assets. In the example above, the forward contract carries risk because the future stock price <span class="math inline">\(S_T\)</span> is unknown at time <span class="math inline">\(0\)</span>. However, perfect hedging is achieved by holding one unit of stock into the future. Since the initial stock price <span class="math inline">\(S_0\)</span> is observable at time <span class="math inline">\(0\)</span>, this strategy eliminates uncertainty, ensuring a risk-free position.</p>
</section>
<section id="options" class="level2">
<h2 class="anchored" data-anchor-id="options">Options</h2>
<p>In real financial markets, more complex financial derivatives are traded, one of which is called <strong>options</strong>. An option is a contract written on an underlying asset, signed at present but granting the holder the <strong>right</strong>, rather than the obligation, to execute it in the future. Unlike a forward contract, the option holder can choose whether to exercise the option based on its profitability at maturity. In our discussion, we assume the underlying asset to be the stock with price <span class="math inline">\(\{S_t\}\)</span>.</p>
<p>A European call option with time to maturity <span class="math inline">\(T\)</span> and strike price <span class="math inline">\(K\)</span> grants the holder the right to buy one unit of stock at time <span class="math inline">\(T\)</span> at price <span class="math inline">\(K\)</span>. If <span class="math inline">\(S_T&gt;K\)</span>, the holder exercises the option, receiving an immediate payoff of <span class="math inline">\(S_T - K\)</span>. If <span class="math inline">\(S_T\leq K\)</span>, the holder does not exercise the option, resulting in a payoff of <span class="math inline">\(0\)</span>. Written compactly, such a European call option has payoff <span class="math display">\[
(S_T - K)_+ := \max\{S_T-K,0\}.
\]</span> Similarly, a European put option with time to maturity <span class="math inline">\(T\)</span> and strike price <span class="math inline">\(K\)</span> grants the holder the right to sell one unit of stock at time <span class="math inline">\(T\)</span> at price <span class="math inline">\(K\)</span>. Its payoff function is given by: <span class="math display">\[
(K-S_T)_+ := \max\{K-S_T,0\}.
\]</span> European options are the simplest ones, yet there exist various other types of options on the market. For example, American options allow the holder to exercise at any time before maturity. Path-dependent options have payoff functions of the form <span class="math inline">\(g(S_{[0,T]})\)</span>, which depend on the entire stock price trajectory over <span class="math inline">\([0,T]\)</span>. A common example is the lookback option, where the payoff is given by <span class="math display">\[
g(S_{[0,T]}) = \sup_{t\in[0,T]} S_t.
\]</span> For a comprehensive introduction to continuous-time finance and option pricing, we refer the readers to <span class="citation" data-cites="bjork2009arbitrage">(<a href="#ref-bjork2009arbitrage" role="doc-biblioref">Björk 2009</a>)</span>.</p>
</section>
</section>
<section id="option-pricing-a-model-based-approach" class="level1">
<h1>Option Pricing— A Model-Based Approach</h1>
<p>We begin by introducing option pricing within the framework of model-based finance, which requires specifying an <em>a priori</em> model for the stock price dynamics <span class="math inline">\(\{S_t\}\)</span>. A well-known and widely used example is the following <a href="https://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model">Black-Scholes (BS) Model</a>: <span class="math display">\[
dS_t = \mu S_t\,dt + \sigma S_t\,dW_t,
\]</span> where <span class="math inline">\(\mu\)</span> denotes the expected return of the stock, <span class="math inline">\(\sigma&gt;0\)</span> denotes the volatility, and <span class="math inline">\(\{W_t\}\)</span> is a standard Brownian motion under measure <span class="math inline">\(\mathbb{P}\)</span>.</p>
<p>To illustrate option pricing under the Black-Scholes model, we present two fundamental approaches for pricing a European call option:</p>
<ol type="1">
<li><p>The hedging approach.</p></li>
<li><p>The risk-neutral pricing (martingale measure) approach.</p></li>
</ol>
<p>Those two approches are fundamentally equivalent, providing different perspectives illustrating the same underlying principle.</p>
<section id="pricing-through-hedging" class="level2">
<h2 class="anchored" data-anchor-id="pricing-through-hedging">Pricing through Hedging</h2>
<p>The first approach to pricing a European call option is based on hedging, which is motivated by the fundamental principle: “If two portfolios have the same payoff, they must have the same price to prevent arbitrage”. Therefore, if we can replicate the payoff of a European call option using a portfolio that consists of cash and stock, the option price is just the price of the replicating portfolio, which only requires trivial calculations. Replication is equivalent to perfect hedging, since selling the replicating portfolio while holding the option eliminates all risk.</p>
<p>Consider a replicating portfolio consisting of:</p>
<ol type="1">
<li><p><span class="math inline">\(a_t\)</span> units of stock at time <span class="math inline">\(t\)</span>.</p></li>
<li><p><span class="math inline">\(b_t\)</span> units of cash at time <span class="math inline">\(t\)</span>.</p></li>
</ol>
<p>The portfolio value at time <span class="math inline">\(t\)</span> is: <span class="math display">\[
V_t = a_tS_t + b_te^{rt}.
\]</span> By Itô’s formula, <span class="math display">\[
dV_t = a_t\,dS_t + S_t\,da_t + \,d\langle S,a\rangle_t + e^{rt}\,db_t + rb_te^{rt}\,dt,
\]</span> where <span class="math inline">\(\langle \cdot,\cdot\rangle_t\)</span> denotes the quadratic variation up to time <span class="math inline">\(t\)</span>. The changes in the portfolio value are due to market movements <span class="math inline">\(a_t\,dS_t + rb_te^{rt}\,dt\)</span> and investor adjustments <span class="math inline">\(S_t\,da_t + \,d\langle S,a\rangle_t + e^{rt}\,db_t\)</span>. Since no external endowments are allowed, the portfolio must be self-financing, meaning that the change in its value is only caused by market movements: <span class="math display">\[
dV_t = a_t\,dS_t  + rb_te^{rt}\,dt.
\]</span> To proceed, we assume the Markovian representation <span class="math inline">\(V_t = u(t,S_t)\)</span>, where <span class="math inline">\(u(t,s)\)</span> denotes the portfolio value at time <span class="math inline">\(t\)</span> on observing <span class="math inline">\(S_t = s\)</span>. Itô’s formula implies <span class="math display">\[
dV_t = \partial_t u\,dt + \partial_s u\,dS_t + \frac{1}{2}\partial_{ss} u\,d\langle S,S\rangle_t.
\]</span> Substituting the dynamics of the Black-Scholes model yields <span class="math display">\[
dV_t = \left(\partial_t u+ \mu S_t\partial_s u + \frac{\sigma^2}{2}S_t^2\partial_{ss}u\right)\,dt + \sigma S_t\partial_s u\,dW_t.
\]</span> By comparing the coefficients, we get <span class="math display">\[
\begin{cases}
a_t = \partial_s u(t,S_t)\\
b_t = \frac{1}{r}e^{-rt}(\partial_t u(t,S_t)+ \frac{\sigma^2}{2}S_t^2\partial_{ss}u(t,S_t))
\end{cases}.
\]</span> Recall that <span class="math inline">\(a_tS_t + b_te^{rt} = V_t = u(t,S_t)\)</span>. Substituting <span class="math inline">\(a_t,b_t\)</span> yields the <a href="https://en.wikipedia.org/wiki/Black%E2%80%93Scholes_equation">Black-Scholes PDE</a> for <span class="math inline">\(u = u(t,s)\)</span>: <span class="math display">\[
\partial_t u + rs\partial_s u + \frac{\sigma^2}{2}s^2\partial_{ss}u - ru = 0,\quad u(T,s) = (s - K)_+.
\]</span> Solving this PDE (a technical step omitted here) provides the celebrated <a href="https://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model">Black-Scholes formula</a> for the European call option price: <span class="math display">\[
V_0 = u(0,S_0).
\]</span></p>
</section>
<section id="risk-neutral-pricing" class="level2">
<h2 class="anchored" data-anchor-id="risk-neutral-pricing">Risk-Neutral Pricing</h2>
<p>The difficulty of pricing lies in the fact that under the physical measure <span class="math inline">\(\mathbb{P}\)</span>, the discounted expected payoff is not equal to the price, due to the existence of risk premium to compensate for the uncertainty taken by the holders of the derivative. That means, if a holder is risk-neutral, the discounted expected payoff is just the price, in which situation the pricing problem reduces to simple calculations of expectations.</p>
<p>Risk-neutral pricing follows this main idea and aims to view the current world through the lens of a <strong>risk-neutral (martingale) measure</strong> <span class="math inline">\(\mathbb{Q}\)</span>, under which all investors are risk-neutral, i.e., <span class="math inline">\(\{e^{-rt}S_t\}\)</span> is a martingale. The European call price is nothing but <span class="math display">\[
e^{-rT}\mathbb{E}_{\mathbb{Q}}(S_T - K)_+.
\]</span> When it comes to the calculation, one needs to guarantee the existence of <span class="math inline">\(\mathbb{Q}\)</span> and the knowledge on the distribution of <span class="math inline">\(S_T\)</span> under <span class="math inline">\(\mathbb{Q}\)</span>. Followed from the fact that <span class="math inline">\(\{e^{-rt}S_t\}\)</span> is a martingale, we rewrite the stock price dynamics: <span class="math display">\[
dS_t = rS_t\,dt + \sigma S_t\left(\frac{\mu - r}{\sigma}\,dt+dW_t\right),
\]</span> denoting <span class="math inline">\(dW_t^\mathbb{Q}:= \frac{\mu - r}{\sigma}\,dt+dW_t\)</span> as the BM under <span class="math inline">\(\mathbb{Q}\)</span>. An application of Girsanov theorem guarantees the existence of <span class="math inline">\(\mathbb{Q}\)</span> and provides the Radon-Nikodym derivative between the physical measure and the risk-neutral measure. Solving for the SDE yields <span class="math display">\[
S_t = e^{(r-\frac{\sigma^2}{2})t + \sigma W_t^{\mathbb{Q}}},
\]</span> which tells the explicit distribution of <span class="math inline">\(S_T\)</span> under <span class="math inline">\(\mathbb{Q}\)</span>. After performing calculations, one yields exactly the same <a href="https://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model">Black-Scholes formula</a> for the European call option price as the one derived from hedging.</p>
</section>
<section id="market-completeness-and-super-replication" class="level2">
<h2 class="anchored" data-anchor-id="market-completeness-and-super-replication">Market Completeness and Super-Replication</h2>
<p>Martingale measures serve as a crucial component in mathematical finance and are known to be associated with several fundamental theorems. To name a few, the <a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_asset_pricing">First Fundamental Theorem of Asset Pricing</a> states that the market is viable (arbitrage-free) if and only if at least one martingale measure exists. The <a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_asset_pricing">Second Fundamental Theorem of Asset Pricing</a> claims that the market is complete iff the martingale measure exists and is unique. Without even realizing it, the market completness greatly simplifies the problem of option pricing in a Black-Scholes market.</p>
<p>A viable market is called <strong>complete</strong> if any European payoffs at any time of maturity <span class="math inline">\(T\)</span> can be perfectly replicated. It turns out that the perfect replicability of European call and put payoffs implies the perfect replicability of any European payoff functions (<a href="https://gregorygundersen.com/blog/2023/01/26/carr-madan/">Carr-Madan formula</a>). That means, the European call and put payoffs serve as the “basis” for all European payoffs. Option pricing in a complete market (e.g., the Black-Scholes market) is therefore easy, but unfortunately is almost never the case in real life.</p>
<p>One of the common examples of an incomplete market is the stochastic volatility model, where the volatility <span class="math inline">\(\{\sigma_t\}\)</span> is also a stochastic process with its dynamics given by an SDE under a different Brownian motion. There is only one risky asset but two sources of randomness (i.e., one Brownian motion for <span class="math inline">\(S\)</span> and one for <span class="math inline">\(\sigma\)</span>), which causes the failure of perfect replication. Intuitively understanding through an analogue to the solvability of linear systems, the market is complete (a linear system has a unique solution) if and only if the number of different risky assets (number of equations) equals the number of different sources of randomness (number of unknowns).</p>
<p>As we would naturally expect, pricing becomes much harder in an incomplete market, since the arbitrage-free price is an interval, rather than a single number. On the side of hedging, perfectly hedging becomes impossible. On the side of risk-neutral pricing, there exist infinitely many martingale measures. A new pricing criterion is given by super-replication instead, i.e., ensuring the payoff of the replicating portfolio is larger than the payoff of the option. The minimal cost of super-replication for an option writer, denoted by <span class="math inline">\(C_{\text{sell}}\)</span>, is the highest arbitrage-free price on the market. Conversely, taking the perspective of an option buyer, one can define <span class="math inline">\(C_{\text{buy}}\)</span> as the maximal cost of sub-replication, which is the lowest arbitrage-free price on the market. Therefore, the interval of arbitrage-free price is provided by <span class="math inline">\([C_{\text{buy}},C_{\text{sell}}]\)</span>.</p>
<p>The super-replication approach sounds natural and attractive from the hedging perspective, but what can we say about martingale measures? Does that mean the hedging perspective would be superior over the martingale measure approach in an incomplete market? Surprisingly, the super-replication duality <span class="citation" data-cites="henry2017model">(<a href="#ref-henry2017model" role="doc-biblioref">Henry-Labordère 2017</a>)</span> holds, which can be proved using the <a href="https://en.wikipedia.org/wiki/Fenchel%27s_duality_theorem">Fenchel-Rockafeller Duality</a>, stating that the minimum cost of super-replication is equal to the maximum martingale price. This result implies that hedging strategies and martingale measures are two sides of the same coin, in the sense that they should be understood as dual optimization variables of each other.</p>
</section>
</section>
<section id="option-pricing-a-model-free-approach" class="level1">
<h1>Option Pricing— A Model-Free Approach</h1>
<p>Motivated by the super-replication that goes beyond the requirement of market completeness, we introduce option pricing in the model-free finance context. The basic settings of model-free option pricing are:</p>
<ol type="1">
<li><p>No <em>a priori</em> knowledge on the stock price dynamics is assumed.</p></li>
<li><p>The only information available are the empirical observations of derivative prices traded on the market.</p></li>
<li><p>The market is incomplete.</p></li>
</ol>
<p>By the <a href="https://github.com/PavanAnanthSharma/Breeden-Litzenberger-formula-for-risk-neutral-densities">Breeden-Litzenberger Formula</a>, empirical observations of European call prices for a continuum of strikes <span class="math inline">\(K\in\mathbb{R}_+\)</span> with maturity <span class="math inline">\(T\)</span> recovers the marginal distribution of the stock price <span class="math inline">\(S_T\)</span> under the martingale measure. Therefore, within the discussions below, we always assume the knowledge of the marginal distribution of <span class="math inline">\(S_T\)</span>.</p>
<p>Although it is practically impossible to observe European call prices for a continuum of strikes <span class="math inline">\(K\)</span>, several approaches can be taken to fix this problem:</p>
<ol type="1">
<li><p>Adding constraints to the optimization problems stated below <span class="citation" data-cites="henry2017model">(<a href="#ref-henry2017model" role="doc-biblioref">Henry-Labordère 2017</a>)</span>. The constraints reflect the fact that European call prices are observed for only finitely many strikes <span class="math inline">\(K\)</span>.</p></li>
<li><p>Interpolate or approximate the implied volatility surface to predict European call prices at unknown strikes <span class="math inline">\(K\)</span>.</p></li>
</ol>
<p>In the following context, we always assume <span class="math inline">\(r=0\)</span> without loss of generality, and all optimization problems are stated based on the perspective of an option writer. In other words, the solutions to those optimization problems provide the maximum arbitrage-free prices of the options. Similar formulations can be adopted from the perspective of option buyers that provide the minimum arbitrage-free prices of the options.</p>
<section id="pricing-options-with-joint-payoffs" class="level2">
<h2 class="anchored" data-anchor-id="pricing-options-with-joint-payoffs">Pricing Options with Joint Payoffs</h2>
<p>Assume there are two stocks on the market with stock prices <span class="math inline">\(\{S^1_t\}\)</span> and <span class="math inline">\(\{S^2_t\}\)</span>. We wish to price a European option with maturity <span class="math inline">\(T\)</span> and a given payoff function <span class="math inline">\(C\)</span>, which is a joint function in both stock prices, i.e.&nbsp;<span class="math inline">\(c(S^1_T,S^2_T)\)</span>. Denote by <span class="math inline">\(\mathbb{P}^1\)</span> and <span class="math inline">\(\mathbb{P}^2\)</span> the laws of <span class="math inline">\(S^1_T\)</span> and <span class="math inline">\(S^2_T\)</span> under the martingale measure (known). The seller’s price is the minimum cost of super-replication: <span class="math display">\[
\text{MK}_2:=\inf_{(\lambda_1,\lambda_2)\in \mathscr{P}^*(\mathbb{P}^1,\mathbb{P}^2)} \mathbb{E}_{\mathbb{P}^1}\lambda_1(S^1_T) + \mathbb{E}_{\mathbb{P}^2}\lambda_2(S^2_T),
\]</span> where <span class="math display">\[
\mathscr{P}^*(\mathbb{P}^1,\mathbb{P}^2) := \{(\lambda_1,\lambda_2):\lambda_1(s_1) + \lambda_2(s_2)\geq c(s_1,s_2)\}.
\]</span> The objective function is the cost of replication with European payoffs <span class="math inline">\(\lambda_1\)</span> and <span class="math inline">\(\lambda_2\)</span>, while <span class="math inline">\(\mathscr{P}^*(\mathbb{P}^1,\mathbb{P}^2)\)</span> is the collection of payoff functions that admits a super-replication.</p>
<p>Through the <a href="https://www.otwiki.xyz/wiki/Kantorovich_Dual_Problem_(for_general_costs)">Kantorovich Duality</a>, it is clear that <span class="math display">\[
\text{MK}_2=\sup_{\mathbb{P}\in\mathscr{P}(\mathbb{P}^1,\mathbb{P}^2)}\mathbb{E}_{\mathbb{P}}[c(S^1_T,S^2_T)],
\]</span> where <span class="math inline">\(\mathscr{P}(\mathbb{P}^1,\mathbb{P}^2)\)</span> is the collection of probability measures, under which <span class="math inline">\(S^1_T\sim \mathbb{P}^1\)</span> and <span class="math inline">\(S^2_T\sim \mathbb{P}^2\)</span>.</p>
<p>We remark that, the primal and dual optimization problems align with those in optimal transport. However, those optimization problems no longer have the physical interpretation as transport problems, but are interpreted in the sense of hedging. Nevertheless, this optimization problem can be numerically solved through techniques that have been developed for optimal transport, e.g., <a href="https://www.otwiki.xyz/wiki/Sinkhorn%27s_Algorithm">Sinkhorn’s Algorithm</a>.</p>
</section>
<section id="pricing-options-with-path-dependent-payoffs" class="level2">
<h2 class="anchored" data-anchor-id="pricing-options-with-path-dependent-payoffs">Pricing Options with Path-dependent Payoffs</h2>
<p>Assume there is a single stock considered at two different time points <span class="math inline">\(t_1&lt;t_2\)</span>. For simplicity, we denote <span class="math inline">\(S_1:= S_{t_1}\)</span> and <span class="math inline">\(S_2:= S_{t_2}\)</span>. The path-dependent option payoff has the form <span class="math inline">\(c(S_1,S_2)\)</span>. Denote by <span class="math inline">\(\mathbb{P}^1\)</span> and <span class="math inline">\(\mathbb{P}^2\)</span> the laws of <span class="math inline">\(S^1\)</span> and <span class="math inline">\(S^2\)</span> under the martingale measure (known).</p>
<p>The seller’s price is the minimum cost of super-replication: <span class="math display">\[
\widetilde{\text{MK}}_2:=\inf_{(\lambda_1,\lambda_2,H)\in \mathscr{M}^*(\mathbb{P}^1,\mathbb{P}^2)} \mathbb{E}_{\mathbb{P}^1}\lambda_1(S_1) + \mathbb{E}_{\mathbb{P}^2}\lambda_2(S_2),
\]</span> where <span class="math display">\[
\mathscr{M}^*(\mathbb{P}^1,\mathbb{P}^2) := \{(\lambda_1,\lambda_2,H):\lambda_1(s_1) + \lambda_2(s_2) + H(s_1)(s_2-s_1)\geq c(s_1,s_2)\}.
\]</span> The objective function is the cost of replication with European payoffs <span class="math inline">\(\lambda_1\)</span> and <span class="math inline">\(\lambda_2\)</span>, while <span class="math inline">\(\mathscr{M}^*(\mathbb{P}^1,\mathbb{P}^2)\)</span> is the collection of payoff functions and the static trading strategy <span class="math inline">\(H\)</span> that admits a super-replication. Note that due to the presence of two different time points, one can trade the stock at time <span class="math inline">\(0,t_1,t_2\)</span>, which results in the extra <span class="math inline">\(H\)</span> variable in the optimization problem.</p>
<p>Through <a href="https://en.wikipedia.org/wiki/Fenchel%27s_duality_theorem">Fenchel-Rockafeller Duality</a>, one can prove that <span class="math display">\[
\widetilde{\text{MK}}_2=\sup_{\mathbb{P}\in\mathscr{M}(\mathbb{P}^1,\mathbb{P}^2)}\mathbb{E}_{\mathbb{P}}[c(S_1,S_2)],
\]</span> where <span class="math inline">\(\mathscr{M}(\mathbb{P}^1,\mathbb{P}^2)\)</span> is the collection of probability measures, under which <span class="math inline">\(S^1_T\sim \mathbb{P}^1\)</span> and <span class="math inline">\(S^2_T\sim \mathbb{P}^2\)</span> and <span class="math inline">\(\mathbb{E}_{\mathbb{P}}(S_2|S_1) = S_1\)</span>. Clearly, the presence of the constraint <span class="math inline">\(\mathbb{E}_{\mathbb{P}}(S_2|S_1) = S_1\)</span> in the dual problem is the direct consequence of the extra <span class="math inline">\(H\)</span> variable in the primal problem, which is actually a martingale condition restricted to time points <span class="math inline">\(t_1,t_2\)</span>.</p>
<p>This problem is called <strong>martingale optimal transport</strong> due to the extra martingale constraint, which is reasonable to appear due to <span class="math inline">\(\{S_t\}\)</span> being a martingale under the martingale measure when <span class="math inline">\(r=0\)</span>. In other words, the transport trajectory from <span class="math inline">\(\mathbb{P}^1\)</span> to <span class="math inline">\(\mathbb{P}^2\)</span> cannot be arbitrary due to the introduction of two different time points.</p>
<p>Note that unlike <span class="math inline">\(\mathscr{P}^*(\mathbb{P}^1,\mathbb{P}^2)\)</span> which always contains the trivial coupling, extra conditions are required to ensure that <span class="math inline">\(\mathscr{M}(\mathbb{P}^1,\mathbb{P}^2)\)</span> is not empty. An if and only if condition is given by the <strong>convex order</strong> between two measures, denoted <span class="math inline">\(\mathbb{P}^1\leq \mathbb{P}^2\)</span>, which is defined as <span class="math display">\[
\mathbb{E}_{\mathbb{P}^1}(S_1-K)_+\leq \mathbb{E}_{\mathbb{P}^2}(S_2-K)_+,\ \forall K.
\]</span> Through the Black-Scholes formula, one can easily check that if <span class="math inline">\(\{S_t\}\)</span> denotes the stock price in a Black-Scholes market with a single stock, then <span class="math inline">\(\mathbb{P}^1\leq \mathbb{P}^2\)</span> for <span class="math inline">\(\forall 0\leq t_1&lt;t_2\)</span>.</p>



</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-bjork2009arbitrage" class="csl-entry" role="listitem">
Björk, Tomas. 2009. <em>Arbitrage Theory in Continuous Time</em>. Oxford university press.
</div>
<div id="ref-henry2017model" class="csl-entry" role="listitem">
Henry-Labordère, Pierre. 2017. <em>Model-Free Hedging: A Martingale Optimal Transport Viewpoint</em>. Chapman and Hall/CRC.
</div>
<div id="ref-karatzas2021portfolio" class="csl-entry" role="listitem">
Karatzas, Ioannis, and Constantinos Kardaras. 2021. <em>Portfolio Theory and Arbitrage: A Course in Mathematical Finance</em>. Vol. 214. American Mathematical Soc.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/otwiki\.github\.io\/otwiki-main\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // default icon
          link.classList.add("external");
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>