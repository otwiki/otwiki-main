<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Max Emerick">

<title>Dynamic Optimal Transport – OT WIKI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">OT WIKI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Dynamic Optimal Transport</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Max Emerick </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>The dynamic formulation of optimal transport is one of the four main formulations of the optimal transport problem (the other three being the <a href="https://www.otwiki.xyz/wiki/Monge_Problem">Monge Problem</a>, the <a href="https://otwiki.github.io/otwiki-main/Kantorovich_Problem.html">Kantorovich Problem</a>, and the <a href="https://www.otwiki.xyz/wiki/Kantorovich_Dual_Problem_(for_general_costs)">Kantorovich Dual Problem</a>). Rather than minimizing over transport maps or transport plans between measures <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\nu\)</span>, the dynamic formulation of optimal transport minimizes over curves which connect <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\nu\)</span>.</p>
<p>Minimizing over curves (as opposed to maps or plans) has at least two major advantages. First, it allows for continuous interpolation between measures in the Wasserstein space. This is desirable in several applications.</p>
<p>Second, minimization over curves generalizes to many settings where transport maps or plans may not be well defined or may be difficult to define. This allows for the construction of optimal transport-based metrics in nonclassical settings, such as <a href="add_link">Optimal Transport on Graphs</a> or <a href="https://arxiv.org/abs/1508.05216">Unbalanced Optimal Transport</a>.</p>
<p>The original formulation of the dynamic optimal transport problem is due to <span class="citation" data-cites="Benamou2000">(<a href="#ref-Benamou2000" role="doc-biblioref">Benamou and Brenier 2000</a>)</span>. However, a somewhat different formulation is presented in this article following <span class="citation" data-cites="Ambrosio2021">(<a href="#ref-Ambrosio2021" role="doc-biblioref">Ambrosio et al. 2021</a>)</span> which is based on integrals defined on the path space of the underlying metric space. We will compare these two approaches later in this article.</p>
<section id="preliminaries" class="level2">
<h2 class="anchored" data-anchor-id="preliminaries">Preliminaries</h2>
<p>Let <span class="math inline">\((X,d)\)</span> be a metric space. Recall that a curve <span class="math inline">\(\gamma: [a,b] \to X\)</span> is said to be absolutely continuous if there exists <span class="math inline">\(g \in L^1(a,b)\)</span> such that <span class="math display">\[
d(\gamma(r),\gamma(s)) ~\leq~ \int_r^s g(t) \, dt
\]</span> for all <span class="math inline">\(a \leq r \leq s \leq b\)</span>. The space of absolutely continuous curves from <span class="math inline">\([a,b]\)</span> to <span class="math inline">\(X\)</span> is denoted <span class="math inline">\(\text{AC}([a,b],X)\)</span>.</p>
<p>The metric dertivative of <span class="math inline">\(\gamma \in \text{AC}([a,b],X)\)</span> is defined as <span class="math display">\[
|\gamma'|(t) ~:=~ \lim_{h \to 0} \frac{d(\gamma(t),\gamma(t+h))}{|h|} .
\]</span> The metric derivative formalizes the notion of “speed” of the curve <span class="math inline">\(\gamma\)</span>, and is defined for a.e.-<span class="math inline">\(t\)</span>. The metric derivative is the minimal <span class="math inline">\(g\)</span> that can be chosen in the definition of absolute continuity above.</p>
<p>The length of <span class="math inline">\(\gamma\)</span> is then defined as <span class="math display">\[
\ell(\gamma) ~:=~ \int_a^b |\gamma'|(t) \, dt .
\]</span></p>
<p>Note that by reparameterizing the time variable, any curve in <span class="math inline">\(\text{AC}([a,b],X)\)</span> can be transformed into a curve in <span class="math inline">\(\text{AC}([0,1],X)\)</span> with constant speed <span class="math inline">\(|\gamma'| \equiv \ell(\gamma) = \text{constant}\)</span>.</p>
<p>The above definitions imply that for any curve <span class="math inline">\(\gamma \in \text{AC}([a,b],X)\)</span>, it holds that <span class="math inline">\(\ell(\gamma) \geq d(\gamma(a),\gamma(b))\)</span>, i.e., that the length of <span class="math inline">\(\gamma\)</span> is greater than the distance between its endpoints. Any curve which achieves equality <span class="math inline">\(\ell(\gamma) = d(\gamma(a),\gamma(b))\)</span> is termed a geodesic. The space of constant-speed geodesics on the interval <span class="math inline">\([0,1]\)</span> is denoted <span class="math inline">\(\text{Geo}(X)\)</span>.</p>
<p>A metric space <span class="math inline">\(X\)</span> is said to be geodesic if for all <span class="math inline">\(x,y \in X\)</span> there exists <span class="math inline">\(\gamma \in \text{Geo}(X)\)</span> such that <span class="math inline">\(\gamma(0) = x\)</span> and <span class="math inline">\(\gamma(1) = y\)</span>.</p>
<p>See <a href="add_link">Analysis in Metric Spaces</a> for a review of these ideas.</p>
<p>Generalizing the notion of length, the (<span class="math inline">\(p\)</span>-) action of a curve <span class="math inline">\(\gamma \in \text{AC}([0,1],X)\)</span> is defined as <span class="math display">\[
A_p(\gamma) ~:=~ \int_0^1 |\gamma'|^p (t) \, dt .
\]</span> Note that this quantity is possibly infinite. This definition can be extended to all of <span class="math inline">\(C([0,1],X)\)</span> by setting <span class="math inline">\(A_p(\gamma) = + \infty\)</span> if <span class="math inline">\(\gamma \in C([0,1],X) \backslash AC([0,1],X)\)</span>.</p>
<p>Geodesics can then be characterized by a variational principle involving the action.</p>
<section id="lemma." class="level4">
<h4 class="anchored" data-anchor-id="lemma.">Lemma.</h4>
<p>For <span class="math inline">\(\gamma \in \text{AC}([0,1],X)\)</span> and <span class="math inline">\(1 \leq p &lt; \infty\)</span>, <span class="math inline">\(\gamma \in \text{Geo}(X)\)</span> if and only if <span class="math inline">\(A_p(\gamma) = d^p(\gamma(0),\gamma(1))\)</span>.</p>
</section>
<section id="proof." class="level4">
<h4 class="anchored" data-anchor-id="proof.">Proof.</h4>
<p>The forward direction is immediate, since <span class="math inline">\(\gamma \in \text{Geo}(X)\)</span> means that <span class="math inline">\(|\gamma'| \equiv \ell(\gamma) = d(\gamma(0),\gamma(1))\)</span> by definition. The reverse direction follows from Jensen’s inequality, since <span class="math display">\[
A_p(\gamma) ~:=~ \int_0^1 |\gamma'|^p(t) \, dt ~\geq~ \left( \int_0^1 |\gamma'|(t) \, dt \right)^p ~=:~ \ell^p(\gamma) ~\geq~ d^p(\gamma(0),\gamma(1)) ,
\]</span> with equality being achieved if and only if <span class="math inline">\(\gamma \in \text{Geo}(X)\)</span>. <span class="math inline">\(\square\)</span></p>
<p>The space <span class="math inline">\(C([0,1],X)\)</span> is termed the path space over <span class="math inline">\(X\)</span>. The dynamic formulation of optimal transport is posed in terms of probability measures on this path space, i.e., in terms of <span class="math inline">\(\eta \in P(C([0,1],X))\)</span>.</p>
<p>The evaluation map <span class="math inline">\(e_t: C([0,1],X) \to X\)</span> is defined by <span class="math inline">\(e_t(\gamma) := \gamma(t)\)</span>. The evaluation map acts on probability measures on the path space by pushforward <span class="math inline">\((e_t)_\# : P(C([0,1],X)) \to P(X)\)</span>. Thus <span class="math inline">\((e_t)_\# \eta\)</span> is itself a path in <span class="math inline">\(P(X)\)</span>.</p>
</section>
</section>
<section id="the-dynamic-optimal-transport-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-dynamic-optimal-transport-problem">The Dynamic Optimal Transport Problem</h2>
<p>The dynamic optimal transport problem is stated as follows. Given probability measures <span class="math inline">\(\mu, \nu \in P(X)\)</span>, solve <span class="math display">\[
\min_\eta ~ \int_{C([0,1],X)} A_p(\gamma) \, d \eta(\gamma) \qquad \text{s.t.} \qquad \eta \in P(C([0,1],X)), ~~(e_0)_\# \eta = \mu , ~~ (e_1)_\# \eta = \nu .
\]</span> An admissible <span class="math inline">\(\eta\)</span> is termed a dynamic transport plan and an optimal <span class="math inline">\(\eta\)</span> is termed an optimal dynamic tranport plan. This terminology is justified by the fact that <span class="math inline">\(\eta\)</span> is an admissible dynamic transport plan if and only if <span class="math inline">\((e_0,e_1)_\# \eta\)</span> is an admissible tranport plan. A dynamic transport plan <span class="math inline">\(\eta\)</span>, however, encodes not only information about which particles in <span class="math inline">\(\mu\)</span> are transported to which particles in <span class="math inline">\(\nu\)</span>, but about which trajectories these particles take during the transport process.</p>
<section id="theorem." class="level4">
<h4 class="anchored" data-anchor-id="theorem.">Theorem.</h4>
<p>If <span class="math inline">\((X,d)\)</span> is a Polish and geodesic metric space, then the minimum attained for the dynamic optimal transport problem is equal to the minimum attained for the Kantorovich problem. Furthermore, <span class="math inline">\(\eta\)</span> is optimal if and only if <span class="math inline">\((e_0,e_1)_\# \eta\)</span> is optimal for the Kantorovich problem and <span class="math inline">\(\eta\)</span> is supported on <span class="math inline">\(\text{Geo}(X)\)</span>.</p>
</section>
<section id="proof.-1" class="level4">
<h4 class="anchored" data-anchor-id="proof.-1">Proof.</h4>
<p>If <span class="math inline">\(\eta\)</span> is an admissible dynamic transport plan, then <span class="math display">\[
\begin{align}
\int_{C([0,1],X)} A_p(\gamma) \, d\eta(\gamma) ~&amp;\geq~ \int_{C([0,1],X)} d^p(\gamma(0),\gamma(1)) \, d\eta(\gamma) \\
~&amp;=~ \int_{X \times X} d^p(x,y) \, d(e_0,e_1)_\# \eta(x,y) \\
~&amp;\geq~ \min_\pi \mathbb{K}_p(\pi) .
\end{align}
\]</span> To prove the converse, start from an optimal transport plan <span class="math inline">\(\pi\)</span> and for each <span class="math inline">\((x,y) \in X \times X\)</span>, choose <span class="math inline">\(\gamma_{x,y} \in \text{Geo}(X)\)</span> such that <span class="math inline">\(\gamma_{x,y}(0) = x\)</span> and <span class="math inline">\(\gamma_{x,y}(1) = y\)</span>. Define the map <span class="math inline">\(\Gamma: X \times X \to \text{Geo}(X)\)</span> by <span class="math inline">\(\Gamma(x,y) = \gamma_{x,y}\)</span> and the measure <span class="math inline">\(\eta := \Gamma_\# \pi \in P(C([0,1],X))\)</span>. By construction, <span class="math inline">\(\eta\)</span> is supported in <span class="math inline">\(\text{Geo}(X)\)</span>. Thus <span class="math display">\[
\begin{align}
\min_\pi \mathbb{K}_p(\gamma) ~&amp;=~ \int_{X \times X} d^p(x,y) \, d\pi(x,y) \\
~&amp;=~ \int_{C([0,1],X)} d^p(\gamma(0),\gamma(1)) \, d\eta(\gamma) \\
~&amp;=~ \int_{C([0,1],X)} A_p(\gamma) \, d\eta(\gamma)
\end{align}
\]</span> by the previous lemma, and equality is achieved.</p>
<p>Lastly, observe that <span class="math inline">\(\eta\)</span> is optimal if and only if equality is achieved above, which happens if and only if <span class="math inline">\(\gamma\)</span> is supported in <span class="math inline">\(\text{Geo}(X)\)</span> and <span class="math inline">\((e_0,e_1)_\# \eta\)</span> is optimal for the Kantorovich problem. <span class="math inline">\(\square\)</span></p>
</section>
</section>
<section id="comparison-with-original-formulation" class="level2">
<h2 class="anchored" data-anchor-id="comparison-with-original-formulation">Comparison With Original Formulation</h2>
<p>The original formulation of dynamic optimal transport due to <span class="citation" data-cites="Benamou2000">(<a href="#ref-Benamou2000" role="doc-biblioref">Benamou and Brenier 2000</a>)</span> is posed as follows. Given probability measures <span class="math inline">\(\mu, \nu \in P(X)\)</span>, solve <span class="math display">\[
\begin{align}
\min_{\rho,v} ~ \int_0^1 \int_X \| v(t,x) \|^p \, d \rho(t,x) \, dt \qquad \text{s.t.} \qquad &amp;\partial_t \rho(t,x) = - \nabla \cdot (\rho(t,x) v(t,x)), \\
~~ &amp;\rho(0) = \mu, ~~ \rho(1) = \nu .
\end{align}
\]</span> Here, <span class="math inline">\(\rho\)</span> is a time-varying probability measure on <span class="math inline">\(X\)</span> and <span class="math inline">\(v\)</span> is a time-varying vector field which acts to transport <span class="math inline">\(\rho\)</span>. Individual particles are considered to be transported according to <span class="math inline">\(x'(t) = v(x,t)\)</span>, and thus the continuity equation <span class="math inline">\(\partial_t \rho = - \nabla \cdot (\rho v)\)</span> describes how the density <span class="math inline">\(\rho\)</span> evolves under the action of <span class="math inline">\(v\)</span>. (Note the abuse of notation here: the symbol <span class="math inline">\(\rho\)</span> is used both for the measure and for its density function.)</p>
<p>In order to interpret the statement of this problem appropriately, <span class="math inline">\(X\)</span> needs to be a subset of Euclidean space (or some Riemannian manifold) and the continuity equation must be understood in some appropriate weak sense.</p>
<p>See <a href="https://www.otwiki.xyz/wiki/The_continuity_equation_and_Benamour_Brenier_formula">The Continuity Equation and Benamou Brenier Formula</a> and <a href="https://www.otwiki.xyz/wiki/Geodesics_and_generalized_geodesics">Geodesics and Generalized Geodesics</a> for more on these ideas.</p>
<p>If <span class="math inline">\(\mu\)</span> has a density function, then particles start from unique locations, and we can write <span class="math inline">\(\phi(t,x)\)</span> to denote the location (at time <span class="math inline">\(t\)</span>) of the particle which started from location <span class="math inline">\(x\)</span> at time <span class="math inline">\(0\)</span>. It then holds that <span class="math display">\[
\rho(t) ~=~ (\phi(t,\cdot))_\# \rho(0) ~=~ (\phi(t,\cdot))_\# \mu .
\]</span> Substituting this into the objective function and using properties of the pushforward, the objective can be rewritten <span class="math display">\[
~=~ \int_0^1 \int_X \| v(t, \phi(t,x)) \|^p \, d \mu(x) \, dt .
\]</span> Recognizing the quantity <span class="math inline">\(\| v(t,\phi(t,x)) \| = \| \tfrac{d}{dt}\phi(t,x) \|\)</span> as the metric derivative of the trajectory <span class="math inline">\(\phi(\cdot,x)\)</span> and interchanging the order of integration, we obtain <span class="math display">\[
~=~ \int_X \int_0^1 |\phi'(\cdot,x)|^p(t) \, dt \, d\mu(x) ~=:~ \int_X A_p(\phi(\cdot,x)) \, d\mu(x) .
\]</span> Lastly, defining <span class="math inline">\(\eta := \phi_\# \mu\)</span> and letting <span class="math inline">\(\gamma\)</span> range over all possible paths from <span class="math inline">\([0,1]\)</span> into <span class="math inline">\(X\)</span> gives <span class="math display">\[
~=~ \int_{C([0,1],X)} A_p(\gamma) \, d\eta(\gamma) ,
\]</span> thus recovering the formulation presented earlier.</p>
<p>Therefore, when <span class="math inline">\(X\)</span> is a subset of Euclidean space (or a Riemannian manifold) and when <span class="math inline">\(\mu\)</span> has a density with respect to Lebesgue measure, the two formulations presented are equivalent. When <span class="math inline">\(\mu\)</span> does not have a density, the original formulation can be further weakened to maintain equivalence. However, when <span class="math inline">\(X\)</span> is a general metric space, only the earlier formulation in terms of integrals on the path space is valid.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Ambrosio2021" class="csl-entry" role="listitem">
Ambrosio, Luigi, Elia Brué, Daniele Semola, et al. 2021. <em>Lectures on Optimal Transport</em>. Vol. 130. Springer.
</div>
<div id="ref-Benamou2000" class="csl-entry" role="listitem">
Benamou, Jean-David, and Yann Brenier. 2000. <span>“A Computational Fluid Mechanics Solution to the Monge-Kantorovich Mass Transfer Problem.”</span> <em>Numerische Mathematik</em> 84 (3): 375–93.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/otwiki\.github\.io\/otwiki-main\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // default icon
          link.classList.add("external");
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>