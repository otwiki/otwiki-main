<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Fabio Ricci">

<title>Optimal Transport and Ricci Curvature – OT WIKI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">OT WIKI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Optimal Transport and Ricci Curvature</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Fabio Ricci </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introduction-and-motivation" class="level2">
<h2 class="anchored" data-anchor-id="introduction-and-motivation">Introduction and Motivation</h2>
<p>This article provides a brief introduction into a connection of optimal transport and the curvature tensor of a Riemannian manifold. In fact, we are going to study the transport map <span class="math inline">\(T_t(x):=\text{exp}_x( t\xi(x)),\)</span> where <span class="math inline">\(\xi\)</span> denotes a <span class="math inline">\(C^1\)</span> vector field on the manifold <span class="math inline">\((M,g).\)</span></p>
<p>These kind of maps appear very naturally in the context of optimal transport. Recall that in optimal transport one is particularly interested in the Monge Problem, being the following optimization problem: Let <span class="math inline">\((M,g)\)</span> be a compact and connected Riemannian manifold. Let furthermore, <span class="math inline">\(\mu=fdV , \nu=gdV\)</span> denote two probability measures on <span class="math inline">\(M\)</span> which are absolutely continuous with respect to the measure on the manifold, induced by the metric. the Monge Problem is then given by <span class="math inline">\(\inf_{T\#\mu =\nu} \int d(x,T(x))^2\,dV,\)</span> where the infimum is taken among all measurable maps <span class="math inline">\(T:M\rightarrow M\)</span> and <span class="math inline">\(d\)</span> denotes the Metric on <span class="math inline">\((M,g)\)</span> induced by <span class="math inline">\(g.\)</span> Then the Monge Problem admits a unique solution <span class="math inline">\(T.\)</span> Moreover, in that case <span class="math inline">\(T(x)=\exp_x(\nabla \psi(x))\)</span> for some <span class="math inline">\(\psi\)</span> (see <ref name="Figalli">for more details of this).</ref></p>
<p>To conclude the introductory part of this article, let us also mention that these kind of transport maps, turned out to be useful in the area of geometric analysis. In fact, Simon Brendle could prove a Sobolev inequality on non compact Riemannian manifolds with nonnegative Ricci curvature, the proof of which makes use of defining a map which is of the type <span class="math inline">\(T(x)=\exp_x(\nabla u(x))\)</span> ( see proof of Theorem 1.1 in <ref name="Brendle"> for more details).</ref></p>
</section>
<section id="curvature-and-optimal-transport" class="level2">
<h2 class="anchored" data-anchor-id="curvature-and-optimal-transport">Curvature and Optimal Transport</h2>
<p>Let <span class="math inline">\((M,g)\)</span> be a Riemannian manifold. In this article we assume basic knowledge about the notions of curvature and geodesics on a manifold. For some background information on these topics, we refer the reader to Chapter three to five in <ref name="DoCarmo">.</ref></p>
<p>The Goal of this article is to show the follwing ### Proposition Let <span class="math inline">\(T_t(x)=\exp_x(t\nabla \psi (x)),\)</span> where <span class="math inline">\(\psi\)</span> denotes a <span class="math inline">\(C^2\)</span> function on <span class="math inline">\(M\)</span> and let <span class="math inline">\(\mathcal J (t):=\text{log}(\text{det}[d_xT_t]).\)</span> Then the following inequality holds true:</p>
<p><span class="math inline">\(\mathcal J''+\frac{1}{n} \mathcal J'+ \text{Ric}_{\gamma(t)}(\gamma'(t),\gamma'(t))\leq 0, \quad \text{ for all } t \text{ such that } \mathcal J(t)&gt;0,\)</span></p>
<p>where <span class="math inline">\(\gamma\)</span> is defined to be the mapping <span class="math inline">\(t \mapsto T_t(x),\)</span> which is a geodesic.</p>
<p>Notice that this inequality involves the transport map <span class="math inline">\(T\)</span> and the Ricci curvature tensor and therefore constitutes a connection of the curvature and the optimal transport problem.</p>
<section id="remarks" class="level3">
<h3 class="anchored" data-anchor-id="remarks">Remarks</h3>
<p>Before we prove the Proposition, let us do some remarks: let <span class="math inline">\(x \in M\)</span> be given and let <span class="math inline">\(e_i\)</span> for <span class="math inline">\(i = 1, \dots, n\)</span> be an orthonormal basis. After doing parallel transport along <span class="math inline">\(\gamma\)</span>, we have an orthonormal basis also in <span class="math inline">\(T_{T_t(x)}M\)</span>. Let <span class="math inline">\(\textbf J\)</span> denote the matrix representation of <span class="math inline">\(d_xT_t: T_xM\rightarrow T_{T_t(x)}M.\)</span> Then we have that <span class="math inline">\(\textbf J''+R\textbf J=0\)</span> where <span class="math inline">\(R\)</span> denotes the matrix <span class="math inline">\((R(\gamma', e_i,\gamma', e_j))_{i,j}.\)</span> Indeed, this follows right away from the fact that <span class="math inline">\(J_i(t):= d_xT_t(e_i)\)</span> is a Jacobi field along <span class="math inline">\(\gamma\)</span> for each <span class="math inline">\(i =1,\dots,n.\)</span></p>
</section>
<section id="proof-of-the-proposition" class="level3">
<h3 class="anchored" data-anchor-id="proof-of-the-proposition">Proof of the Proposition</h3>
<p>With the notation of the proposition stated above, we compute the derivative of <span class="math inline">\(\mathcal J\)</span> as follows: <span class="math inline">\(\frac{d}{dt}\mathcal J(t) = \text{trace}(\textbf J' \textbf J^{-1})\)</span> which follows right away from Jacobi’s formula. Let now <span class="math inline">\(U(t):=\textbf J' \textbf J^{-1}\)</span>. Since <span class="math inline">\(\textbf J\)</span> satisfies the matrix Jacobi equation as noticed in the preceding remark, we may infer a Ricatti equation for <span class="math inline">\(U\)</span>. Indeed, taking derivative of <span class="math inline">\(U( t)\)</span> we obtain the following equation</p>
<p><span class="math inline">\(U' =\textbf J ''  \textbf J^{-1} +\textbf J' \frac{d}{dt}\textbf J^{-1}.\)</span></p>
<p>Now observe that</p>
<p><span class="math inline">\(\frac{d}{dt}\textbf J^{-1}= - \textbf J^{-1}\textbf J '  \textbf J^{-1}.\)</span></p>
<p>In fact, notice that we only consider <span class="math inline">\(t\)</span> such that <span class="math inline">\(\det( \textbf J) &gt;0\)</span>. Thus the inverse matrix exists for all <span class="math inline">\(t\)</span> in a small neighborhood of that <span class="math inline">\(t\)</span>. Then we have that</p>
<p><span class="math inline">\(0= \frac{d}{dt} 1_n= \frac{d}{dt}\textbf J\textbf J^{-1}= \textbf J'\textbf J^{-1}+\textbf J\frac{d}{dt}\textbf J^{-1}\)</span></p>
<p>from which, after rearranging and multiplying with the inverse from the left, one gets the desired equality. Plugging this into the equation concerning the derivative of <span class="math inline">\(U\)</span>, we get that</p>
<p><span class="math inline">\(U' =\textbf J _  \textbf J^{-1}-\textbf J'\textbf J^{-1}\textbf J '  \textbf J^{-1}= \textbf J _  \textbf J^{-1}- U^2.\)</span></p>
<p>Then, using the matrix Jacobi equation, we get that</p>
<p><span class="math inline">\(U' =-R  \textbf J\textbf J^{-1}-U^2= -R-U^2,\)</span></p>
<p>so that</p>
<p><span class="math inline">\(U' +R+U^2=0.\)</span></p>
<p>Notice that this is a first order ODE. Since <span class="math inline">\(U(0)= \text{Hess } \psi,\)</span> is symmetric, we have that <span class="math inline">\(U^T\)</span> also satisfies the Ricatti equation with same initial condition, from which we get that <span class="math inline">\(U=U^T\)</span>.</p>
<p>Moreover, since the Ricatti equation is an equation of matrices, we can now take the trace in that equation. We therefore obtain that</p>
<p><span class="math inline">\(\text{tr} (U')+\text{Ric}_{\gamma}(\gamma', \gamma')+ \text{tr}(U^2)=0.\)</span></p>
<p>As <span class="math inline">\(U\)</span> is symmetric, we get that <span class="math inline">\(\text{tr}{U^2}\geq \frac{1}{n}\text{tr}(U)^2\)</span>,</p>
<p>we therefore obtain our desired inequality.</p>
</section>
</section>
<section id="ricci-curvature-lower-bounds-and-entropy" class="level2">
<h2 class="anchored" data-anchor-id="ricci-curvature-lower-bounds-and-entropy">Ricci Curvature lower bounds and Entropy</h2>
<p>In this section we will consider a generic measure metric space and we will try to define the notion of Ricci curvature lower bound. In literature was first extended the notion of sectional curvature thanks to the work of Alexandrov <ref>Alexandrov, A. D., A theorem on triangles in a metric space and some applications. Trudy Mat. Inst. Steklov, 38 1951</ref> comparing symmetries of the geodesics triangles, as expected this lower bounds are a natural extension of Sectional Curvature lower bounds, and they coincide in the setting of a Riemannian manifold. This construction became extremely interesting when (40 years later!) Grove and Petersen <ref> Grove, K. &amp; Petersen, P., Manifolds near the boundary of existence. J. Differential Geom., 33 (1991), 379–394</ref> pointed out that this lower bounds are stable under the so called Gromov-Hausdorff convergence. It is well known that the family of Riemannian manifolds with Ricci lower bounds are not closed under the Gromov-Hausdorff convergence or any other reasonable notion of convergence. <span style="color:#0000FF">Is the previous sentence correct? See also the discussion here: [[</span>. We present here an extension of Ricci curvature lower bounds for measure metric spaces that will also preserve this convergence! In the rest of this article we will follow Sturm papers <!-- [@citation](https://mathoverflow.net/questions/161116/ricci-curvature-under-rough-convergence]]) K.-T. Sturm, “On the geometry of metric measure spaces”, Acta Math. 196, p. 65-131 (2006) --> and <!-- [@citation] K.-T. Sturm, “On the geometry of metric measure spaces II”, Acta Math. 196, p. 133-177 (2006) -->. It is important to mention that at the same time of these papers the same results were obtained independently by Lott-Villani in <!-- [@citation] Lott-Villani, Ricci curvature for metric-measure spaces via optimal transport Pages 903-991 from Volume 169 (2009) -->.</p>
<section id="cdk-condition." class="level3">
<h3 class="anchored" data-anchor-id="cdk-condition.">CD(K,<math></math>) condition.</h3>
<p>This is the dimension independent notion of Ricci curvature bounds. We will require our space <span class="math inline">\((M,d,m)\)</span> to be complete and separable and the measure to be locally finite. These assumptions come from the discussion of curvature dimension condition in the well known paper from Bakry and Emery <ref> Bakry, D. &amp; Emery, M. ´ , Diffusions hypercontractives, in S´eminaire de Probabilit´es, XIX, 1983/84, pp.&nbsp;177–206. Lecture Notes in Math., 1123. Springer, Berlin, 1985. </ref>. We denote with <span class="math inline">\(\mathcal{P}_2(M,d,m)\)</span> the subspace of all measures <span class="math inline">\(\nu \in \mathcal{P}_2(M,d)\)</span> that are absolutely continuous with <span class="math inline">\(m\)</span>. We can now apply Radon-Nikodym theorem <!-- [@citation] W. Rudin.  Real and Complex Analysis. New York: McGraw-Hill, 1987. --> and we can write <span class="math inline">\(\nu=\rho m\)</span>, where <span class="math inline">\(\rho\)</span> is the density from the Radon-Nikodym theorem. Using this decomposition we can now define the relative entropy of <span class="math inline">\(\nu\)</span> respect to <span class="math inline">\(m\)</span> in the following way:</p>
<p>:<span class="math inline">\(\operatorname{Ent}(\nu|m)= \lim_{\epsilon \downarrow 0}\int_{\rho &gt;\epsilon} \rho \log \rho dm.\)</span> Note that if <span class="math inline">\(\int_{\rho &gt;1} \rho \log \rho dm &lt;\infty.\)</span> then our definition of entropy coincides with <span class="math inline">\(\int_{\rho &gt;0} \rho \log \rho dm .\)</span>. If that is not satisfied then we just say that <span class="math inline">\(\operatorname{Ent}(\nu|m)=\infty.\)</span> We also say that the entropy is infinity for any measure that is not absolutely continuous with <span class="math inline">\(m\)</span>. We can now define the space of absolutely continuous measures with <span class="math inline">\(m\)</span> that have finite relative entropy respect to <span class="math inline">\(m\)</span>:</p>
<p>:<span class="math inline">\(\mathcal{P}_2^{\star}(M,d,m)=\{\nu \in \mathcal{P}_2(M,d) : \operatorname{Ent}(\nu|m)&lt;\infty\}\)</span>.</p>
<p>It’s very surprising that the notion of curvature is related to the (weak) K-convexity of the relative entropy on <span class="math inline">\(\mathcal{P}_2^{\star}(M,d,m)\)</span>. in the following sense: We say that <span class="math inline">\((M,d,m)\)</span> has curvature globally <span class="math inline">\(\geq K\)</span> for a generic <span class="math inline">\(K \in \mathbb{R}\)</span> if for each pair <span class="math inline">\(\nu_0,\nu_1 \in \mathcal{P}_2^{\star}(M,d,m)\)</span> there exists a geodesics <span class="math inline">\(\Gamma : [0,1] \longrightarrow \mathcal{P}_2^{\star}(M,d,m)\)</span> connecting <span class="math inline">\(\nu_0\)</span> and <span class="math inline">\(\nu_1\)</span> such that:</p>
<p>:<span class="math inline">\(\operatorname{Ent}(\Gamma(t)|m)\leq (1-t)\operatorname{Ent}(\Gamma(0)|m)+t \operatorname{Ent}(\Gamma(1)|m) - \frac{K}{2}t(1-t)d^2_W(\Gamma(0),\Gamma(1)) \text{ for all } t \in [0,1].\)</span>.</p>
<p>We now have an intrinsic notion of curvature that we denote in the following way:</p>
<p>:<span class="math inline">\(\underline{Curv}(M,d,m)=\sup\{ K \in \mathbb{R} : (M,d,m) \text{ has curvature } \geq K \}.\)</span></p>
<p>To make sure that we have introduced an interesting notion of curvature, we need these definition to agree with the classical Ricci curvature lower bounds in the case that our space is also a Riemannian manifold. This indeed happen and it’s Theorem 4.9 in Sturm’s paper and a detailed proof can be found in <ref> von Renesse, M.-K. &amp; Sturm, K.-T., Transport inequalities, gradient estimates, entropy, and Ricci curvature. Comm. Pure Appl. Math., 58 (2005), 923–940 </ref>: If M is a complete Riemannian manifold with Riemannian distance <span class="math inline">\(d\)</span> and volume <span class="math inline">\(m\)</span>, denote with <span class="math inline">\(m'=e^{-V}m\)</span>, where <span class="math inline">\(V\)</span> is a twice differentiable function <span class="math inline">\(V: M \longrightarrow \mathbb{R}\)</span> then we have the following:</p>
<p>:<span class="math inline">\(\underline{Curv}(M,d,m')=\inf\{\operatorname{Ric}_M{\xi,\xi}+\operatorname{Hess}V(\xi,\xi) : \xi \in TM \text{ and } |\xi|=1\}\)</span>.</p>
<p>In particular this tells us that in the Riemannian setting <span class="math inline">\((M,d,m)\)</span> has curvature <span class="math inline">\(\geq K\)</span> if and only if Ricci curvature is <span class="math inline">\(\geq K\)</span>.</p>
</section>
<section id="cdkn-condition." class="level3">
<h3 class="anchored" data-anchor-id="cdkn-condition.">CD(K,N) condition.</h3>
<p>In the previous section we have defined a dimensional independent notion of curvature lower bound. We want now to reinforce the curvature bound <span class="math inline">\(Curv \geq K\)</span> by adding a condition on the dimension. There are the so called <span class="math inline">\(CD(K,N)\)</span> conditions where <span class="math inline">\(K\)</span> has to be intended as lower bound for the curvature and <span class="math inline">\(N\)</span> as an upper bound for the dimension. The notion of curvature we discussed in the previous section will coincide, in some sense, when <span class="math inline">\(N=\infty\)</span>. Again this new construction will coincide with the usual notion of Ricci curvature lower bound in the case we have a Riemannian manifold. The main idea is to substitute the relative entropy with the Renyi entropy functional (note that this is interesting for finite N):</p>
<p>:<span class="math inline">\(S_N(\nu|m)=-\int \nu^{1-\frac{1}{N}}\)</span>.</p>
<p>It is easy to state the <span class="math inline">\(CD(0,N)\)</span> condition, it simply means that for all <span class="math inline">\(N'\geq N\)</span> the entropy functional we have just defined <span class="math inline">\(S_N(\cdot|m)\)</span> is convex on the <span class="math inline">\(L_2-\)</span>Wasserstein space <span class="math inline">\(\mathcal{P}_2(M,d)\)</span>. In the case of a Riemannian manifold this characterizes manifolds with dimension <span class="math inline">\(\leq N\)</span> and Ricci curvature <span class="math inline">\(\geq 0\)</span>, this result can be found in<!-- [@citation] K. Sturm, Convex functionals of probability measures and nonlinear diffusions on manifolds. J. Math. Pures Appl., 84 (2005), 149–168 -->. The argument is based on the fact that the Jacobian determinant <span class="math inline">\(J_t=\det dF_t\)</span> of any transport map <span class="math inline">\(T_t=\exp (-t\nabla \phi)\)</span> satisfies <span class="math inline">\(\frac{\partial^2}{\partial t^2}J_t^{\frac{1}{N}} \leq 0\)</span> if and only if <span class="math inline">\(M\)</span> has dimension <span class="math inline">\(\leq N\)</span> and Ricci curvature <span class="math inline">\(\geq 0\)</span>. It can also be proved that this condition is equivalent to the Brunn-Minkowski inequality:</p>
<p>:<span class="math inline">\(m(A_t)^{\frac{1}{N'}}\geq (1-t) m(A_0)^{\frac{1}{N'}}+tm(A_1)^{\frac{1}{N'}},\)</span></p>
<p>For any <span class="math inline">\(N'\geq N\)</span>, any <span class="math inline">\(t \in [0,1]\)</span> and any pair of sets <span class="math inline">\(A_0,A_1 \subset M\)</span> where <span class="math inline">\(A_t\)</span> denotes the set of points <span class="math inline">\(\gamma_T\)</span> on geodesics with endpoints <span class="math inline">\(\gamma_0 \in A_0\)</span> and <span class="math inline">\(\gamma_1 \in A_1\)</span>.</p>
<p>The condition <span class="math inline">\(CD(K,N)\)</span> for a general <span class="math inline">\(K \in \mathbb{R}\)</span> is more complicated, assuming measurable choice of a unique geodesic condition: the existence of a unique geodesic <span class="math inline">\(\gamma_t(x,y)\)</span> connecting <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> for <span class="math inline">\(m\otimes m\)</span>-almost any <span class="math inline">\((x,y) \in M^2\)</span>. Then choose any two absolutely continues probability measures, thanks to Radon Nykodim we can write them as <span class="math inline">\(\rho_0 m\)</span> and <span class="math inline">\(\rho_1 m\)</span>, then there existes an optimal coupling <span class="math inline">\(q\)</span> that satisfies:</p>
<p>:<span class="math inline">\(\rho_t(\gamma_t(x,y)) \leq \Big( \tau_{K,N}^{(1-t)}(d(x,y))\rho_0^{-\frac{1}{N}}(x)+\tau_{K,N}^{(t)}(d(x,y))\rho_1^{-\frac{1}{N}}(y)\Big)^{-N}.\)</span> for all <span class="math inline">\(t \in [0,1]\)</span> and <span class="math inline">\(q\)</span>- almost everywhere <span class="math inline">\((x,y)\in M^2\)</span>, denoted with <span class="math inline">\(\rho_t\)</span>, the density of the push-forward of <span class="math inline">\(q\)</span> under the map <span class="math inline">\((x,y) \mapsto \gamma_t(x,y)\)</span> and <span class="math inline">\(\tau\)</span> is defined in the following way, denote <span class="math inline">\(H=\sqrt{\frac{K}{N-1}}\)</span>:</p>
<p>:<span class="math inline">\(\tau_{K,N}^{(t)}=t^{\frac{1}{N}}\Big(\frac{\sin(Ht\theta}{\sin(H\theta}\Big)^{1-\frac{1}{N}}\)</span>. With the usual hyperbolic function interpretation when <span class="math inline">\(K\leq 0\)</span>.</p>
<p>It can be shown that the condition on the Jacoby determinant is replaced now by<!-- [@citation] K. Sturm, Convex functionals of probability measures and nonlinear diffusions on manifolds. J. Math. Pures Appl., 84 (2005), 149–168 Corollary 3.4 -->:</p>
<p>:<span class="math inline">\(\frac{\partial^2}{\partial t^2}J_t^{\frac{1}{N}} \leq -\frac{K}{N} J_t^{\frac{1}{N}}(x)d^2(x,F_1(x))\)</span>.</p>
<p>This leads to a distorted Brunn-Minkowski type inequality:</p>
<p>:<span class="math inline">\(J_t^{\frac{1}{N}}(x)\geq \tau_{K,N}^{(1-t)}(d(x,T_1(x)))J_0^{\frac{1}{N}}(x)+\tau_{K,N}^{(t)}(d(x,T_1(x)))J_1^{\frac{1}{N}}(x)\)</span>.</p>
<p>Again in this case, this is the usual notion of Ricci curvature lower bound if our space has the extra structure of a Riemannian manifold. The proof of this, together with all the result mentioned were also developed independently in <ref> J. Lott, C. Villani, Ricci curvature for metric-measure spaces via optimal transport. (2005).</ref></p>
</section>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p><references></references></p>
<p><ref name="Figalli"> <a href="https://cedricvillani.org/sites/dev/files/old_images/2012/08/P12.CIME_.pdf">A. Figalli, C. Villiani, <em>OPTIMAL TRANSPORT AND CURVATURE</em>, Notes for a CIME lecture course in Cetraro, June 2009</a> </ref></p>
<p><ref name="Brendle "> <a href="https://arxiv.org/abs/2009.13717">S. Brendle, <em>Sobolev inequalities in manifolds with nonnegative curvature</em>, 2021. arXiv: 2009.13717.</a> </ref></p>
<p><ref name="DoCarmo "> <a href="https://books.google.com/books/about/Riemannian_Geometry.html?id=ct91XCWkWEUC">M. P. do Carmo, <em>Riemannian Geometry</em>,Mathematics: Theory &amp; Applications. Birkhauser Boston, Inc., Boston, MA, 1992</a> </ref></p>
<p></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/otwiki\.github\.io\/otwiki-main\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>