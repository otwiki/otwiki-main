<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Evan Tufte">

<title>Estimation of Transport Maps – OT WIKI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">OT WIKI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Estimation of Transport Maps</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Evan Tufte </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Ordinarily in optimal transport, you’re given two probability measures <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\nu\)</span> and tasked to find the cheapest way to transport <span class="math inline">\(\mu\)</span> to <span class="math inline">\(\nu\)</span>. But in many applications, you don’t know explicitly what the probability measures <span class="math inline">\(\mu\)</span> and/or <span class="math inline">\(\nu\)</span> are, but are able to obtain samples from either of them through experiments or data collection.</p>
<p>This article discusses two approaches to estimate optimal transport maps, only given samples from <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\nu\)</span>. The below follows the presentation in <span class="citation" data-cites="CNWR2019">(<a href="#ref-CNWR2019" role="doc-biblioref">Chewi, Niles-Weed, and Rigollet 2019</a>)</span>. The first approach is to immediately replace <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\nu\)</span> by their empirical measures (which are discrete approximations of <span class="math inline">\(\mu\)</span>, <span class="math inline">\(\nu\)</span>), solve for an optimal transport plan, then use this to construct an approximate transport map. The other approach is to go to the semidual reformulation of the optimal transport problem, replace <span class="math inline">\(\mu\)</span> ad <span class="math inline">\(\nu\)</span> by their empirical measures, then use the optimal transport map of this modified problem as an estimator for the optimal transport map.</p>
</section>
<section id="setting" class="level1">
<h1>Setting</h1>
<p>Let <span class="math inline">\((X,d)\)</span> be a <a href="https://en.wikipedia.org/wiki/Complete_metric_space">complete</a>, <a href="https://en.wikipedia.org/wiki/Separable_space">separable</a> <a href="https://en.wikipedia.org/wiki/Metric_space">metric space</a>. Let <span class="math inline">\(\mathcal{P}(X)\)</span> be the set of all (<a href="https://en.wikipedia.org/wiki/Borel_set">Borel</a>) <a href="https://en.wikipedia.org/wiki/Probability_measure">probability measures</a> on <span class="math inline">\(X\)</span>. For a measurable function <span class="math inline">\(T:X \to X\)</span>, and <span class="math inline">\(\mu \in \mathcal{P}(X)\)</span>, the <a href="https://en.wikipedia.org/wiki/Pushforward_measure">pushforward</a> of <span class="math inline">\(\mu\)</span> by <span class="math inline">\(T\)</span>, denoted <span class="math inline">\(T \# \mu\)</span>, is defined by <span class="math display">\[
T \# \mu(A) = \mu(T^{-1}(A)).
\]</span> If <span class="math inline">\(T \# \mu = \nu\)</span>, we say <span class="math inline">\(T\)</span> transports <span class="math inline">\(\mu\)</span> to <span class="math inline">\(\nu\)</span>.</p>
<p>The <a href="https://www.otwiki.xyz/wiki/Monge_Problem">Monge problem</a> is: given probability measures <span class="math inline">\(\mu , \nu \in \mathcal{P}(X)\)</span> and a cost function <span class="math inline">\(c:X \times X \to [0,\infty)\)</span>, find a function <span class="math inline">\(T\)</span> which minimizes <span id="eq-Monge"><span class="math display">\[
\min_T \mathbb{M}(T) = \min_T \int c(x,T(x)) d \mu(x),
\tag{1}\]</span></span> where the minimum is taken over all (measurable) functions <span class="math inline">\(T:X \to X\)</span> with <span class="math inline">\(T \# \mu =\nu\)</span>. A mimizer <span class="math inline">\(T\)</span> of <a href="#eq-Monge" class="quarto-xref">Equation&nbsp;1</a> is called an optimal transport map. In general an optimal transport map need not exist, and may not be unique.</p>
<p>One usefull sufficient condition for existance and uniqueness is Brenier’s theorem (stated <a href="https://www.otwiki.xyz/wiki/Monge_Problem">here</a>)</p>
<!---Throughout the rest of the article, we will assume $X = \mathbb{R}^d$, and the cost function $c$ is $c(x,y) = |x-y|^2$. This makes the the minimum value equal to the 2-Wasserstein distance between $\mu$ and $\nu$ (link!!) ($W_2(\mu,\nu)$). 
--->
</section>
<section id="problem-description" class="level1">
<h1>Problem Description</h1>
<p>The problem of esitimating transport maps is: given samples <span class="math inline">\(X_1,...,X_n\)</span> which are <a href="https://en.wikipedia.org/wiki/Independent_and_identically_distributed_random_variables">independent identically distributed</a> (i.i.d.) with distribution <span class="math inline">\(\mu\)</span>, and <span class="math inline">\(Y_1,...,Y_n\)</span> which are i.i.d. with distribution <span class="math inline">\(\nu\)</span>, find an estimator <span class="math inline">\(\widehat{T}\)</span> for the optimal transport map <span class="math inline">\(T\)</span> for the Monge Problem.</p>
</section>
<section id="empirical-measures" class="level1">
<h1>Empirical Measures</h1>
<section id="definition-of-empirical-measures" class="level2">
<h2 class="anchored" data-anchor-id="definition-of-empirical-measures">Definition of Empirical Measures</h2>
<p>For a point <span class="math inline">\(x \in \mathbb{R}^d\)</span>, define the dirac mass at <span class="math inline">\(x\)</span> to be <span class="math display">\[
\delta_x(A) = \begin{cases} 1 &amp; \text{ if } x \in A\\
0 &amp; \text{ if } x \not\in A
\end{cases}
\]</span> This is the measure which gives one unit of mass to <span class="math inline">\(x\)</span>, and zero to everything else. Now, given the samples <span class="math inline">\(X_1,...,X_n\)</span> and <span class="math inline">\(Y_1,...,Y_n\)</span> we can define the empirical measures <span class="math display">\[
\mu_n = \frac{1}{n} ( \delta_{X_1} + \cdots + \delta_{X_n})
\]</span> <span class="math display">\[
\nu_n = \frac{1}{n} ( \delta_{Y_1} + \cdots + \delta_{Y_n})
\]</span> Technically, the empirical measures are families of measures: one for each realization of the random variables <span class="math inline">\(X_1,...,X_n\)</span> (for <span class="math inline">\(\mu_n\)</span>), <span class="math inline">\(Y_1,...,Y_n\)</span> (for <span class="math inline">\(\nu_n\)</span>). The intuition for <span class="math inline">\(\mu_n\)</span> is this; <span class="math display">\[
\mu_n(A) = \frac{(\text{number of } X_i \text{'s in } A)}{n},
\]</span> and when <span class="math inline">\(n\)</span> is large this will be approximately equal to <span class="math inline">\(\mu(A)\)</span>. And indeed, for any measurable <span class="math inline">\(A \subseteq \mathbb{R}^d\)</span>, we have <span class="math inline">\(\mu_n(A) \to \mu(A)\)</span> almost surely.</p>
</section>
<section id="kantorovich-problem" class="level2">
<h2 class="anchored" data-anchor-id="kantorovich-problem">Kantorovich Problem</h2>
<p>The <a href="https://otwiki.github.io/otwiki-main/Kantorovich_Problem.html">Kantorovich</a> formulation of optimal transport is very often used in place of the Monge problem. It has several better properties for analysis (discussed <a href="https://otwiki.github.io/otwiki-main/Kantorovich_Problem.html">here</a>). Moreover, the discrete Kantorovich problem is a linear progaming problem (as discussed on p.13–14 in <span class="citation" data-cites="CNWR2019">(<a href="#ref-CNWR2019" role="doc-biblioref">Chewi, Niles-Weed, and Rigollet 2019</a>)</span>).</p>
<p>Here is the formal problem statement of the Kantorovich problem. Let <span class="math inline">\(\mu, \nu \in \mathcal{P}(X)\)</span>, and let <span class="math inline">\(c:X \times X \to [0,\infty)\)</span> be a cost function. The set of addmissible transport plans is defined to be <span class="math display">\[
\Gamma(\mu,\nu) = \{ \gamma \in P(X \times X): \pi_1\# \gamma = \mu \text{ and } \pi_2 \# \gamma = \nu\}
\]</span> where <span class="math inline">\(\pi_1, \pi_2:X \times X \to X\)</span> are the canonical projections <span class="math inline">\(\pi_1(x,y) = x\)</span>, <span class="math inline">\(\pi_2(x,y)=y\)</span>. The Kantorovich optimal transport problem is:</p>
<p><span id="eq-Kant"><span class="math display">\[
\min_{\gamma \in \Gamma(\mu,\nu)} \mathbb{K}( \gamma) = \min_{\gamma \in \Gamma(\mu,\nu)} \int_{X \times Y} c(x,y) d \gamma.
\tag{2}\]</span></span></p>
<p>A <span class="math inline">\(\gamma \in \Gamma(\mu,\nu)\)</span> which achieves this minimum is called an optimal transport plan.</p>
<p>Given any transport map <span class="math inline">\(T\)</span>, you can construct a transport plan: <span class="math inline">\(\gamma = (id,T)\# \mu\)</span>. This transport plan just sends mass at <span class="math inline">\(x\)</span> to <span class="math inline">\(T(x)\)</span>. Under the hypothoses of Brenier’s theorem, the minimum in Monge’s and Kantorovich’s problems is the same, the minimizers of both are unique, and the relationship is this: if <span class="math inline">\(T\)</span> is an optimal transport map, then <span class="math inline">\((id,T) \# \mu\)</span> is an optimal transport plan, and any optimal transport plan <span class="math inline">\(\gamma\)</span> is of this form.</p>
</section>
<section id="first-estimator" class="level2">
<h2 class="anchored" data-anchor-id="first-estimator">First Estimator</h2>
<p>One possible approach to estimating <span class="math inline">\(T\)</span> is to replace <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\nu\)</span> by their empirical measure counterparts <span class="math inline">\(\mu_n\)</span> and <span class="math inline">\(\nu_n\)</span>. Then, solve the empirical version of the Kantorovich problem: <span class="math display">\[
  \min_{\gamma \in \Gamma(\mu_n,\nu_n)} \mathbb{K}_n( \gamma) = \min_{\gamma \in \Gamma(\mu_n,\nu_n)} \int_{X \times X} c(x,y) d \gamma(x,y)
\]</span> Let <span class="math inline">\(\gamma_n\)</span> be the minimizer. Then, try to find a transport map <span class="math inline">\(\widehat{T}\)</span> which induces the transport plan <span class="math inline">\(\gamma_n\)</span> (that is, find a function <span class="math inline">\(\widehat{T}:X \to X\)</span> such that <span class="math inline">\((id,\widehat{T}) \# \mu_n = \gamma_n\)</span>).</p>
<p>To do this, note: every element of <span class="math inline">\(\Gamma(\mu_n,\nu_n)\)</span> is a convex combination of dirac masses at sample points <span class="math inline">\((X_i,Y_j)\)</span>. So, <span class="math inline">\(\gamma_n\)</span> will be a convex combination of dirac masses at sample points <span class="math inline">\((X_i,Y_j)\)</span>. Whenever one of the dirac masses <span class="math inline">\(\delta_{(X_i,Y_j)}\)</span> appears in <span class="math inline">\(\gamma_n\)</span> with positive coefficient, you should define <span class="math inline">\(T(X_i) = Y_j\)</span>. However, if the transport plan ever splits mass (that is, sends positive mass from <span class="math inline">\(X_i\)</span> to <span class="math inline">\(Y_{j_1}\)</span>, and sends more positive mass from <span class="math inline">\(X_i\)</span> to <span class="math inline">\(Y_{j_2}\)</span>) there will be no optimal transport map.</p>
<p>There are two major drawbacks to this approach: (1) as mentioned above, <span class="math inline">\(\widehat{T}\)</span> might not even exist, and (2) this approach only tells you what <span class="math inline">\(\widehat{T}(X_1)\)</span>, …, <span class="math inline">\(\widehat{T}(X_n)\)</span> are, but doesn’t tell you what <span class="math inline">\(T_n(x)\)</span> is for any other <span class="math inline">\(x\)</span>. There is no standard choice from this for how <span class="math inline">\(\widehat{T}\)</span> should be defined anywhere but at <span class="math inline">\(X_1,...,X_n\)</span>. Several methods have been proposed. One simple way is to define <span class="math inline">\(\widehat{T}(x)\)</span> to be <span class="math inline">\(\widehat{T}(X_i)\)</span> where <span class="math inline">\(X_i\)</span> is the nearest sample to <span class="math inline">\(x\)</span>.</p>
</section>
</section>
<section id="the-semidual-formulation" class="level1">
<h1>The Semidual Formulation</h1>
<section id="the-dual-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-dual-problem">The Dual Problem</h2>
<p>The dual of the Kantorovich problem is <span class="math display">\[\sup \int_X f(x) d\mu (x) + \int_Y g(y) d \mu(y)\]</span> where the supremum is taken over all <span class="math inline">\(f \in L^1(\mu), g \in L^1(\nu)\)</span> such that <span class="math inline">\(f(x) + g(y) \leq c(x,y)\)</span>. Here, <span class="math display">\[L^1(\mu) = \{ f:X \to X \text{ measurable }: \int_X |f|d \mu &lt; \infty\}.\]</span> Moreover, we have the follwing theorm (this is Theorem 1.3 in <span class="citation" data-cites="villani2021topics">(<a href="#ref-villani2021topics" role="doc-biblioref">Villani 2021</a>)</span>, you can find a proof there):</p>
<div id="thm-dualEquiv" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (Equivalence of Primal and Dual)</strong></span> Suppose that <span class="math inline">\(c: X \times X \to [0,\infty)\)</span> is lower semi-continuous. Then, <span class="math display">\[\sup_{f(x)+ g(y) \leq c(x,y)} \int_X f(x) d\mu (x) + \int_X g(y) d \nu(y)= \inf_{\gamma \in \Gamma(\mu,\nu)} \mathbb{K}(\gamma)
\]</span> moreover, the infimum on the right hand side is attained.</p>
</div>
</section>
<section id="the-semidual-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-semidual-problem">The Semidual problem</h2>
<p>Assume <span class="math inline">\(\mu, \nu \in \mathcal{P}(\mathbb{R}^d)\)</span> have finite second moments. That is, assume <span class="math display">\[\int_{\mathbb{R}^d} |x|^2 d \mu(x), \quad\int_{\mathbb{R}^d} |y|^2 d \nu(y)&lt; \infty.
\]</span> Also, assume the cost function is <span class="math inline">\(c(x,y) = |x-y|^2\)</span>. The dual problem be further transformed into a problem of optimizing over just one function. <span class="math display">\[\sup_{f(x)+ g(y) \leq c(x,y)} \int_X f(x) d\mu (x) + \int_Y g(y) d \mu(y) = \inf_{\phi \in L^1(\mu)} S(\phi)\]</span> where <span id="eq-semidual"><span class="math display">\[S(\phi) = \int \phi d \mu + \int \phi^* d \nu \tag{3}\]</span></span> Here, <span class="math inline">\(\phi^*\)</span> is the <a href="https://en.wikipedia.org/wiki/Convex_conjugate">convex conjugate</a> of <span class="math inline">\(\phi\)</span>, defined by <span class="math display">\[
\phi^*(y) = \sup_{x \in \mathbb{R}^d} (\langle x,y\rangle - \phi(x)).
\]</span> Moreover, the minimizer of <a href="#eq-semidual" class="quarto-xref">Equation&nbsp;3</a> may be taken to be a convex, lower semicontinuous function <span class="math inline">\(\phi\)</span>. For this convex, lower semicontinuous minimizer <span class="math inline">\(\phi\)</span>, the function <span class="math inline">\(T = \nabla \phi\)</span> is an optimal transport map. (see sections 1.5.2 and 1.5.3 in <span class="citation" data-cites="CNWR2019">(<a href="#ref-CNWR2019" role="doc-biblioref">Chewi, Niles-Weed, and Rigollet 2019</a>)</span>).</p>
</section>
<section id="semidual-estimator" class="level2">
<h2 class="anchored" data-anchor-id="semidual-estimator">Semidual Estimator</h2>
<p>This way of rewriting the Monge problem suggests a way to approximate <span class="math inline">\(T\)</span>: replace <span class="math inline">\(\mu, \nu\)</span> by the empirical measures in the expression for <span class="math inline">\(S(\phi)\)</span>. That is, find a minimizer <span class="math inline">\(\widehat{\phi}\)</span> for <span class="math display">\[
\min_{\phi \in \mathcal{F}} S_n(\phi) =  \min_{\phi \in \mathcal{F}}\int \phi d \mu_n + \int \phi^* d \nu_n.
\]</span> (the class of functions minimized over <span class="math inline">\(\mathcal{F}\)</span> is chosen to suit the problem at hand, see sections 3.2-3.6 of <span class="citation" data-cites="CNWR2019">(<a href="#ref-CNWR2019" role="doc-biblioref">Chewi, Niles-Weed, and Rigollet 2019</a>)</span>). Then define <span class="math inline">\(\widehat{T} = \nabla \widehat{\phi}\)</span>. This has the advantage over the empirical exitmator that <span class="math inline">\(\widehat{T}(x)\)</span> is defined for all <span class="math inline">\(x \in \mathbb{R}^d\)</span>.</p>
<p><span class="citation" data-cites="CNWR2019">(<a href="#ref-CNWR2019" role="doc-biblioref">Chewi, Niles-Weed, and Rigollet 2019</a>)</span> discusses the convergence of <span class="math inline">\(\widehat{T}\)</span> to <span class="math inline">\(T\)</span> (in the <span class="math inline">\(L^2(\mu)\)</span> sense) under certain circumstances and proves bounds for the convergence rate.</p>



</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-CNWR2019" class="csl-entry" role="listitem">
Chewi, Sinho, Jonathan Niles-Weed, and Philippe Rigollet. 2019. <em>Statistical Optimal Transport</em>. Springer. <a href="https://arxiv.org/abs/2407.18163">https://arxiv.org/abs/2407.18163</a>.
</div>
<div id="ref-villani2021topics" class="csl-entry" role="listitem">
Villani, Cédric. 2021. <em>Topics in Optimal Transportation</em>. Vol. 58. American Mathematical Soc.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/otwiki\.github\.io\/otwiki-main\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>