<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Regularity of Optimal Transport Maps and the Monge-Ampére Equation on Riemannian Manifolds – OT WIKI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">OT WIKI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Regularity of Optimal Transport Maps and the Monge-Ampére Equation on Riemannian Manifolds</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Christian Hong and Zach Wagner </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>When considering the [[Monge Problem]], it is natural to ask about the regularity of optimal transport maps (when they exist). In particular, we can consider the Monge Problem variant</p>
<p><span class="math inline">\(\inf_{T} \left \{ F(T) := \int_{X} |x - T(x)|^2 d \mu \right \}\)</span></p>
<p>where we are taking the infimum over all transport plans for our associated measures. The transport maps, <span class="math inline">\(T\)</span>, have the condition <span class="math inline">\(\nu = T \# \mu\)</span> where <span class="math inline">\(\nu\)</span> and <span class="math inline">\(\mu\)</span> are probability measures. One can reformulate the Monge problem into a boundary value problem for a specific partial differential equation. From there, one can ask about the regularity of solutions to the PDE, which are associated with optimal transport plans. In this exposition, we follow the references from Santambrogio<ref name="Santambrogio"> and Figalli<ref name="Regularity">.</ref></ref></p>
<section id="the-monge-ampère-equation" class="level2">
<h2 class="anchored" data-anchor-id="the-monge-ampère-equation">The Monge Ampère Equation</h2>
<p>The Monge Ampère Equation<ref name="Santambrogio"> is a nonlinear second-order elliptic partial differential equation. Let us consider the [[Monge Problem]] from earlier, with starting measure <span class="math inline">\(\mu\)</span>, a target measure <span class="math inline">\(\nu\)</span>. If we require <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\nu\)</span> be absolutely continuous with respect to the Lebesgue measure, we can show that a transport plan, <span class="math inline">\(T\)</span> must satisfy the equation</ref></p>
<p>:<span class="math inline">\(g(y) = \frac{f(T^{-1}(y))}{\det (DT(T^{-1}(y)))}\)</span></p>
<p>where <span class="math inline">\(f(y)\)</span> and <span class="math inline">\(g(y)\)</span> are the densities for <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\nu\)</span> respectively. Recall that we are considering the Monge problem variant :<span class="math inline">\(\inf_{T} \left \{ F(T) := \int_{X} |x - T(x)|^2 d \mu \right \}\)</span>. By Brenier’s Theorem<ref name="Santambrogio">, we know that <span class="math inline">\(T = \nabla u\)</span>, where <span class="math inline">\(u\)</span> is a convex function. If we require <span class="math inline">\(u\)</span> to be strictly convex, substituting <span class="math inline">\(\nabla u\)</span> for <span class="math inline">\(T\)</span> gives us the Monge Ampère equation</ref></p>
<p>:<span class="math inline">\(\det (D^2 u(x)) = \frac{f(x)}{g(\nabla u(x))}\)</span></p>
<dl>
<dt>From here, we can ask about regularity of solutions of to the PDE, which in turns gives us regularity on <span class="math inline">\(T = \nabla u\)</span>. For example, we have the following theorem.</dt>
<dd>
<p><strong>Theorem.</strong><ref name="Santambrogio"> If <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> are <span class="math inline">\(C^{0, \alpha}(\Omega)\)</span> and are both bounded from above and from below on the whole <span class="math inline">\(\Omega\)</span> by positive constants and <span class="math inline">\(\Omega\)</span> is a convex open set, then the unique Brenier solution of <span class="math inline">\(u\)</span> of the Monge Ampère equation belongs to <span class="math inline">\(C^{2, \alpha} (\Omega) \cap C^{1, \alpha} {\overline{\Omega}}\)</span>, and <span class="math inline">\(u\)</span> satisfies the equation in the classical sense. Here, a Brenier solution simply implies that <span class="math inline">\(T\)</span> is a transport plan from <span class="math inline">\(f\)</span> to <span class="math inline">\(g\)</span>.</ref></p>
</dd>
</dl>
<p>Note that the support of <span class="math inline">\(g\)</span> is very relevant when trying to show regularity of our transport plan. Without any conditions on the support of <span class="math inline">\(g\)</span>, <span class="math inline">\(T\)</span> may have singularities. To see this, consider the following simple example: let <span class="math inline">\(f(x):=2\)</span> and <span class="math inline">\(g(x):=2\)</span> be real functions supported on <span class="math inline">\((-1,1)\)</span> and <span class="math inline">\((-2,-1)\cup(1,2)\)</span>, respectively. The optimal transport map will be the gradient of the function <span class="math inline">\(u(x):=|x|+\frac{1}{2}x^2\)</span>, which is convex but lacks the desired regularity. The issue here arises from the disconnectedness of the support of <span class="math inline">\(g\)</span>.<ref name="Regularity"></ref></p>
<dl>
<dt>On the other hand, conditions on the support of <span class="math inline">\(g\)</span> can eliminate such singularities. For example, Caffarelli has shown that if <span class="math inline">\(f,g\)</span> are smooth and strictly positive on their support, and the support of <span class="math inline">\(g\)</span> is convex, the optimal transport plan will be smooth in the support of <span class="math inline">\(f\)</span>. Moreover, if both supports are smooth and uniformly convex, one can show that the optimal transport plan is a smooth diffeomorphism between the support of <span class="math inline">\(f\)</span> and the support of <span class="math inline">\(g\)</span>. In addition to the previous theorem, we get the following restated from Figalli:</dt>
<dd>
<p><strong>Theorem.</strong><ref name="Regularity"> Let <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\nu\)</span> be two compactly supported probability measures on <span class="math inline">\(R^n\)</span>. If <span class="math inline">\(\mu\)</span> is absolutely continuous with respect to the Lebesgue measure, then: :* There exists a unique solution <span class="math inline">\(T\)</span> to the Monge problem. :* The optimal map <span class="math inline">\(T\)</span> is characterized by the structure <span class="math inline">\(T(x) = \nabla u(x)\)</span>, for some convex function <span class="math inline">\(u: R^n \to R\)</span>. :Furthermore, if <span class="math inline">\(\mu(dx) = f(x)dx\)</span>, and <span class="math inline">\(\nu(dy) = g(y) dy\)</span>, :<span class="math inline">\(| \mathrm{det} (\nabla T(x)) | = \frac{f(x)}{g(T(x))}\)</span> for <span class="math inline">\(\mu\)</span>-a.e. <span class="math inline">\(x \in R^n\)</span></ref></p>
</dd>
</dl>
<p>Note that many of these notions, such as Lebesgue measure, gradients, and the Monge Ampère Equation, all have well-defined generalizations on all Riemannian manifolds. In particular, the above theorem was able to be extended to compact Riemannian manifolds<ref name="Regularity">.</ref></p>
</section>
<section id="existence-and-uniqueness-on-riemannian-manifolds" class="level2">
<h2 class="anchored" data-anchor-id="existence-and-uniqueness-on-riemannian-manifolds">Existence and Uniqueness on Riemannian Manifolds</h2>
<p>In order to extend the theory from the previous section to Riemannian manifolds, we need the following definitions.</p>
<p>:<strong>Definition.</strong><ref name="Regularity"> Let <span class="math inline">\(c: X \to Y\)</span> be an arbitrary function. A function is <span class="math inline">\(\psi: X \to R \cup \{+\infty\}\)</span> is <strong>c-convex</strong> if :<span class="math inline">\(\psi(x) = \sup_{y \in Y} \left[\psi^c(y) - c(x,y)\right]\)</span> for all <span class="math inline">\(x \in X\)</span>, where :<span class="math inline">\(\psi^c(y) = \inf_{x \in X} \left[\psi(x) + c(x, y) \right]\)</span> for all <span class="math inline">\(y \in Y\)</span>.</ref></p>
<p>:Moreover, for a <span class="math inline">\(c\)</span>-convex function <span class="math inline">\(\psi(x)\)</span>, we can definite its <span class="math inline">\(c\)</span>-subdifferential at <span class="math inline">\(x\)</span> as</p>
<p>:<span class="math inline">\(\partial^c \psi(x) := \{ y \in Y \, | \, \psi(x) = \psi^c(y) - c(x, y) \}\)</span></p>
<p><em>Remark:</em> Let <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> be <span class="math inline">\(R^n\)</span>. Observe that if <span class="math inline">\(-c(x,y)\)</span> is the Euclidean inner product, then if <span class="math inline">\(\psi\)</span> is <span class="math inline">\(c\)</span>-convex we have,</p>
<p>:<span class="math inline">\(\psi^c(y) = \inf_{x \in X} \left[\psi(x) -x\cdot y \right]=-\sup_{x \in X} \left[x\cdot y - \psi(x)\right]=\psi^*(y)\)</span></p>
<p>which corresponds with the convex conjugate of <span class="math inline">\(\psi\)</span>. Consequently,</p>
<p>:<span class="math inline">\(\psi(x)=\sup_{y \in Y} \left[\psi^c(y) - c(x,y)\right]=\sup_{y \in Y} \left[x\cdot y-\psi^*(x)\right]=\psi^{**}(x)\)</span></p>
<p>Thus, if <span class="math inline">\(\psi\)</span> is proper, <span class="math inline">\(\psi\)</span> is convex since it is equivalent to <span class="math inline">\(\psi^{**}\)</span>.</p>
<p>With this, we can write down the desired theorem, restated from Figalli. :<strong>Theorem.</strong><ref name="Regularity"> Let <span class="math inline">\((M, g)\)</span> be a Riemannian manifold, take <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\nu\)</span> two compactly supported measures on <span class="math inline">\(M\)</span>, and consider the optimal transport problem from <span class="math inline">\(\mu\)</span> to <span class="math inline">\(\nu\)</span> with cost <span class="math inline">\(c(x,y) = d(x,y)^2/2\)</span>, where <span class="math inline">\(d(x,y)\)</span> denotes the Riemannian distance on <span class="math inline">\(M\)</span> If <span class="math inline">\(\mu\)</span> is absolutely continuous with respect to the volume measure, then: :* There exists a unique solution <span class="math inline">\(T\)</span> to the Monge problem. :* <span class="math inline">\(T\)</span> is characterized by the structure <span class="math inline">\(T(x) = \exp_x (\nabla \psi(x)) \in \partial^c \psi(x)\)</span> for some <span class="math inline">\(c\)</span>-convex function <span class="math inline">\(\psi: M \to R\)</span> :* For <span class="math inline">\(\mu_0\)</span>-a.e. <span class="math inline">\(x \in M\)</span>, there exists a unique minimizing geodesic from <span class="math inline">\(x\)</span> to <span class="math inline">\(T(x)\)</span>, which is given by <span class="math inline">\(t \to \exp_x(t\nabla \psi(x)) \in [0,1]\)</span> :Furthermore, if <span class="math inline">\(\mu(dx) = f(x) \mathrm{vol}(dx)\)</span>, and <span class="math inline">\(\nu(dy) = g(y) \mathrm{vol}(dy)\)</span>, :<span class="math inline">\(|\det(\nabla T(x))| = \frac{f(x)}{g(T(x))}\)</span> for <span class="math inline">\(\mu\)</span>-a.e. <span class="math inline">\(x \in M\)</span>.</ref></p>
<p><em>Remark:</em> Some care should be taken with the above formula. The determinant of <span class="math inline">\(\nabla T(x)\)</span> depends on the the tangent space at <span class="math inline">\(x\)</span>. Fortunately, <span class="math inline">\(|\det(\nabla T(x))|\)</span> may be computed independently of <span class="math inline">\(T_xM\)</span>.</p>
</section>
<section id="regularity-on-compact-riemannian-manifolds" class="level2">
<h2 class="anchored" data-anchor-id="regularity-on-compact-riemannian-manifolds">Regularity on Compact Riemannian Manifolds</h2>
<p>We discuss the results of Ma, Trudinger, Wang, and Loeper to extend regularity of optimal transport maps to Riemannian manifolds<ref name="Regularity">. Once again, we will make use of the Monge Ampère Equation, :<span class="math inline">\(|\det(\nabla T(x))| = \frac{f(x)}{g(T(x)}\)</span> to make claims about regularity. Recall that we want the condition <span class="math inline">\(T(x) = \exp_x (\nabla \psi(x)) \in \partial^c \psi(x)\)</span>. It can be shown that this is equivalent to :<span class="math inline">\(\nabla \psi(x) + \nabla_x c(x, T(x)) = 0\)</span> By differentiating the above identity with respect to <span class="math inline">\(x\)</span> and writing everything in charts, we get the equation :<span class="math inline">\(\det (D^2\psi(x)) + D_x^2 c(x, \exp_x (\nabla \psi(x))) = \frac{f(x) \mathrm{vol}_x}{g((T(x))\mathrm{vol}_{T(x)}|\det (d_{\nabla \psi(x)}\exp_x |}\)</span> which is very similar to the Monge Ampère Equation we derived for transport maps in <span class="math inline">\(R^n\)</span>. We simply have a perturbation of <span class="math inline">\(D_x^2 c(x, \exp_x (\nabla \psi(x)))\)</span>. This perturbation can obstruct smoothness. One can try to take the second derivative of the previous equation in order to make an a priori estimate on the second derivatives of <span class="math inline">\(\psi\)</span>. Doing so requires a condition on the sign of the <strong>Ma-Trundinger-Wang tensor:</strong> :<span class="math inline">\(\vartheta_{(x,y)} (\xi, \eta) := \frac{3}{2} \sum_{ijklrs} (c_{ij,r}c^{r,s}c_{s,kl} - c_{ij,kl})\xi^i \xi^j \eta^k \eta^l, \, \xi \in T_xM, \eta \in T_yM\)</span>.</ref></p>
<p>We often write “MTW tensor” intead of Ma-Trundinger-Wang tensor. Moreover, the <strong>MTW Condition</strong> is: :<span class="math inline">\(\vartheta_{(x,y)}(\xi, \eta) \ge 0\)</span> whenever <span class="math inline">\(\sum_{ij} c_{i,j}\xi^i\eta^j = 0\)</span>.</p>
<p>From here, one can prove the Riemannian analogue to one of the regularity theorems we mentioned for the Monge problem in <span class="math inline">\(R^n\)</span>. The theorem is as follows:</p>
<p>:<strong>Theorem.</strong><ref name="Regularity"> Let <span class="math inline">\((M, g)\)</span> be a Riemannian manifold. Assume the MTW condition holds, that <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> are smooth and bounded away from zero and infinity on their respective supports <span class="math inline">\(\Omega\)</span> and <span class="math inline">\(\Omega'\)</span>, and that the cost function <span class="math inline">\(c=d^2/2\)</span> is smooth on the set <span class="math inline">\(\overline{\Omega} \times \overline{\Omega'}\)</span>. Finally, suppose that: :* <span class="math inline">\(\Omega\)</span> and <span class="math inline">\(\Omega'\)</span> are smooth; :* <span class="math inline">\((\exp_x)^{-1}(\Omega') \subset T_xM\)</span> is uniformly convex for all <span class="math inline">\(x \in \Omega\)</span>; :* <span class="math inline">\((\exp_y)^{-1}(\Omega) \subset T_yM\)</span> is uniformly convex for all <span class="math inline">\(y \in \Omega'\)</span>. :Then <span class="math inline">\(\psi \in C^{\infty} (\overline{\Omega})\)</span>, and <span class="math inline">\(T: \overline{\Omega} \to \overline{\Omega'}\)</span> is a smooth diffeomorphism.</ref></p>
<section id="the-mtw-condition-and-its-consequences" class="level3">
<h3 class="anchored" data-anchor-id="the-mtw-condition-and-its-consequences">The MTW Condition and its Consequences</h3>
<p>At a first glance, the MTW condition seems highly technical and it is not clear why it plays a role in the regularity theorem above. Indeed, working through the proof, one sees where the MTW condition is crucial, but it is not intuitively clear why one should think of employing the condition. Loeper realized that connectedness of the <span class="math inline">\(c\)</span>-subdifferential was required for the desired regularity conditions discussed above. This connection arises naturally as an extension of the fact that regularity classical convex solutions to the Monge Ampère Equation requires connectivity of the sub-differential. In fact, Loeper showed that connectedness of the <span class="math inline">\(c\)</span>-subdifferential is equivalent to the MTW condition, hence its need for regularity.<ref name="Regularity"></ref></p>
<p>Fortunately, the MTW condition is satisfied by the most canonical manifolds, including <span class="math inline">\(R^n\)</span>, <span class="math inline">\(T^n\)</span>, and <span class="math inline">\(S^n\)</span> (in fact, quotients of <span class="math inline">\(S^n\)</span> also satisfy the MTW condition).</p>
</section>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p><references> <ref name="Santambrogio"><a href="https://link.springer.com/book/10.1007/978-3-319-20828-2">F. Santambrogio, <em>Optimal Transport for Applied Mathematicians</em>, p.&nbsp;18, 54-57</a></ref> <ref name="Regularity"><a href="http://www.numdam.org/item/AST_2010__332__341_0.pdf">A. Figalli, <em>Regularity of optimal transport maps</em></a></ref> </references></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/otwiki\.xyz");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>