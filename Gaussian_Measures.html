<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Gaussian Measures – OT WIKI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">OT WIKI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Gaussian Measures</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Gaussian Measures are ubiquitous throughout analysis, statistics, and many applied subjects. To a large extent this may be seen as a consequence of the central limit theorem, which in plain terms says that rescaled sums of sufficiently uncorrelated random variables converge to Gaussian variables. In particular quantities like height that depend on many variables will often times follow a gaussian distribution. For reasons we will see later, they also help us understand analysis in infinite dimensional spaces.</p>
<section id="in-finite-dimensions" class="level1">
<h1>In Finite Dimensions</h1>
<p><strong>Definition</strong>: We say a borel measure on <span class="math inline">\(\mathbb{R}^n\)</span> is Gaussian if either of the following equivalent characterizations hold</p>
<ol type="1">
<li><span class="math inline">\(\mu=0\)</span> or else <span class="math inline">\(\mu\)</span> is absolutely continuous w.r.t. Lebesgue with either <span class="math display">\[
\frac{d\mu}{dx}=\frac{1}{\sqrt{2\pi|\det \Sigma|}}\exp\{-\frac{1}{2}\langle x-m, \Sigma^{-1}(x-m)\rangle\}
\]</span></li>
<li>the fourier transform of <span class="math inline">\(\mu\)</span>, <span class="math inline">\(\hat{\mu}\)</span> is given by <span class="math display">\[
\hat{\mu}(x)=\exp\{-i\langle x,m\rangle-\frac{1}{2}\langle x,\Sigma x\rangle\}
\]</span></li>
</ol>
<p>For some <span class="math inline">\(\mu\in \mathbb{R}^n\)</span> called the <em>mean</em> and a positive definite symmetric matrix <span class="math inline">\(\Sigma\)</span> called the covariance matrix.</p>
<p>In general, it will be useful to work with the Fourier transforms of probability measures since we’d like to frame the theory of Gaussian measures in terms of mathematical objects that make sense in infinite dimensions. Unfortunately as we will see, Gaussian measures can’t be described in terms of a density with respect to some analog of Lebesgue measure (or even other gaussian measures in general). Thus the key properties of Gaussian measures that will be relevant to understanding applications to stochastic processes and quantum field theory are the following</p>
<ol start="3" type="1">
<li>Gaussian measures are uniquely determined by their Fourier transform by Bochner’s theorem in the sense that there’s a correspondence <span class="math display">\[
\{\text{Gaussian measures } \mu\} \leftrightarrow \{\text{positive semi-definite symmetric matrices } \Sigma\} \\
\]</span> where <span class="math inline">\(\mu\)</span> determines its covariance matrix, and from each p.d. symmetric matrix <span class="math inline">\(\Sigma\)</span> we can define <span class="math inline">\(\hat{\mu}(x)=\exp\{-\frac{1}{2}\langle x,\Sigma x\rangle\}\)</span> which determines <span class="math inline">\(\mu\)</span> by Fourier inversion.</li>
<li>If <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\nu\)</span> are two Gaussian measures on <span class="math inline">\(\mathbb{R}^n\)</span> then <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\nu\)</span> are mutually absolutely continuous and <span class="math display">\[
\frac{d\mu}{d\nu} = \frac{d\mu}{dx}\left(\frac{d\nu}{dx}\right)^{-1}=  \exp\{\langle x,m_\mu-m_\nu\rangle-\frac{1}{2}\left(\langle m_\mu,\Sigma^{-1}m_\mu\rangle-\langle m_\nu,\Sigma^{-1}m_\nu\rangle\right)\}
\]</span> As an important special case, we see that translating a Gaussian measure <span class="math inline">\(\mu\)</span> by a vector <span class="math inline">\(y\)</span> to create a new measure <span class="math inline">\(\mu_y\)</span> given by <span class="math inline">\(\mu_y(B)=\mu(B-y)\)</span>. If we take <span class="math inline">\(\mu\)</span> to be the <em>standard</em> gaussian in <span class="math inline">\(\mathbb{R}^n\)</span> (i.e.&nbsp;<span class="math inline">\(\mu=0\)</span> and <span class="math inline">\(\Sigma=\operatorname{Id}\)</span>) then this reduces to <span class="math display">\[
\frac{d\mu_y}{d\mu} =  \exp\{\langle x,y\rangle-\frac{1}{2}\|y\|^2\}
\]</span> I emphasize this point because it will allow for a nice comparison with its generalization to infinite dimensions. For proofs of the above facts, see <span class="citation" data-cites="Stroock">(<a href="#ref-Stroock" role="doc-biblioref">Stroock [2023]</a>)</span> or <span class="citation" data-cites="BogachevGM">(<a href="#ref-BogachevGM" role="doc-biblioref">Bogachev [1998]</a>)</span>.</li>
</ol>
</section>
<section id="in-infinite-dimensions" class="level1">
<h1>In Infinite Dimensions</h1>
<p>When working on infinite dimensional spaces, for example spaces of all possible paths between points or all possible distributions, we’d like to have an analog of integral calculus. For example, the translation invariance of Lebesgue measure gives us integration by parts formulas and the tools of Fourier analysis amongst other tools. In particular, we’d like to have a translation invariant measure on infinite dimensional Banach spaces. Unfortunately, in such spaces, the unit ball contains <strong>infinitely many disjoint balls of radius</strong> <span class="math inline">\(\frac{\sqrt{2}}{2}\)</span>, which will imply that any translation invariant measure must assign infinite or zero mass to balls. We give the formal statement and proof.</p>
<section id="lebesgue-measure-does-not-exist-in-infinite-dimensions" class="level2">
<h2 class="anchored" data-anchor-id="lebesgue-measure-does-not-exist-in-infinite-dimensions">Lebesgue Measure Does not Exist in Infinite Dimensions</h2>
<p>Here is the formal statement that captures the fact that we can’t have a Lebesgue measure in infinite dimensions.</p>
<p><strong>Theorem</strong>: Let <span class="math inline">\(X\)</span> be an infinite dimensional separable Banach space. If <span class="math inline">\(\mu\)</span> is a translation invariant Borel measure on <span class="math inline">\(X\)</span> then either <span class="math inline">\(\mu\)</span> assigns infinite measure to each ball or it assigns measure <span class="math inline">\(0\)</span> to each ball in <span class="math inline">\(X\)</span>.</p>
<p>For a full proof, see <span class="citation" data-cites="Eldredge">(<a href="#ref-Eldredge" role="doc-biblioref">Eldredge 2016</a>)</span> or <span class="citation" data-cites="Stroock">(<a href="#ref-Stroock" role="doc-biblioref">Stroock [2023]</a>)</span>. Here is a sketch of the proof in the case where <span class="math inline">\(X=l^2\)</span> is the space of square summable sequences. This special case, however, illustrates the key idea of the proof: namely that any ball contains infinitely many disjoint balls. Let <span class="math inline">\(e_n\)</span> be the ``standard basis” in <span class="math inline">\(l^2\)</span>. That is, the entries of <span class="math inline">\(e_n\)</span> are given by <span class="math display">\[
e_n(m) = \begin{cases}
    0 &amp; m\neq n \\
    1 &amp; m=n
\end{cases}
\]</span> Now observe that if <span class="math inline">\(m\neq n\)</span>, <span class="math inline">\(|e_n-e_m|=\sqrt{2}\)</span> so if <span class="math inline">\(B(x,r)\)</span> denotes the open ball of radius <span class="math inline">\(r\)</span>, we see that <span class="math inline">\(\left\{B\left(e_n,\frac{\sqrt{2}}{2}\right)\right\}_{n=1}^\infty\)</span> is a countable collection of disjoint open balls, each of which is contained in <span class="math inline">\(B(0,2)\)</span> since if <span class="math inline">\(x\in B\left(e_n,\frac{\sqrt{2}}{2}\right)\)</span> then <span class="math display">\[
    |x|\leq |x-e_n|+|e_n|&lt;\frac{\sqrt{2}}{2}+1&lt;2
\]</span> But then by additivity and translation invariance, <span class="math display">\[
\begin{align*}
    \mu(B(0,2)) &amp;= \sum_{n=1}^\infty \mu\left(B\left(e_n,\frac{\sqrt{2}}{2}\right)\right) \\
    &amp;= \sum_{n=1}^\infty \mu\left(B\left(0,\frac{\sqrt{2}}{2}\right)\right)
\end{align*}
\]</span> hence if <span class="math inline">\(\mu\)</span> assigns positive measure to <span class="math inline">\(B\left(0,\frac{\sqrt{2}}{2}\right)\)</span> then it must give infinite measure to <span class="math inline">\(B\left(0,2\right)\)</span>. By translation invariance we can show that any ball of radius <span class="math inline">\(2\)</span> must have positive measure. More generally we can use this argument with the radii appropriately rescales to show that if <span class="math inline">\(\mu\)</span> assigns positive measure to some ball, it must assign infinite measure to all balls.</p>
</section>
<section id="probability-measures-in-infinite-dimension" class="level2">
<h2 class="anchored" data-anchor-id="probability-measures-in-infinite-dimension">Probability Measures in Infinite Dimension</h2>
<p>Throughout, suppose that <span class="math inline">\(\mu\)</span> is a borel probability measure on a a separable Banach space <span class="math inline">\(X\)</span>. In finite dimensions, we saw that the <a href="https://en.wikipedia.org/wiki/Covariance">covariance matrix</a> and mean characterized Gaussian measures. As usual, when we jump to infinite dimensions, matrices should be replaced with operators. Since any <span class="math inline">\(f\in X^*\)</span> is continuous, it is in particular borel measurable. In this setting, we define the covariance of two linear functionals as <span class="math display">\[
    q(f,g) := \langle f,g\rangle_{L^2(X,\mu)}=\int_X f(x)g(x)d\mu(x)
\]</span> which is a bounded bilinear form. For gaussian measures on finite dimensional spaces, one can check that <span class="math inline">\(q(f,g)=\langle f,\Sigma g\rangle\)</span>.</p>
<p>Since there is no infinite dimensional Lebesgue measure, we’d hope to be able to define a Gaussian measure in terms of its Fourier transform. One can indeed define a Gaussian measure on <span class="math inline">\(X\)</span> as one whose Fourier transform is <span class="math inline">\(\exp\{-\frac{1}{2}q(x,x)^2\}\)</span> for a sufficiently nice bilinear form <span class="math inline">\(q\)</span> on <span class="math inline">\(X^*\)</span>. The details of this definition are not relevant to us, but the theory of Fourier transforms of measures on Banach spaces (called characteristic functionals) is developed in <span class="citation" data-cites="BogachevRef">(<a href="#ref-BogachevRef" role="doc-biblioref">Bogachev 2006</a>)</span> Chapter 7 and <span class="citation" data-cites="Kuo">(<a href="#ref-Kuo" role="doc-biblioref">Kuo [1975]</a>)</span> Chapter 1. Intuitively what it means to say that <span class="math inline">\(\mu\)</span> is a Gaussian measure is that it “looks” Gaussian on every finite dimensional subspace. A more concrete definition that coincides with the definition in terms of the Fourier tranform is the following.</p>
<p><strong>Definition</strong>: A borel probability measure <span class="math inline">\(\mu\)</span> on <span class="math inline">\(X\)</span> is <em>Gaussian</em> if for every linear functional <span class="math inline">\(f\in X^*\)</span>, <span class="math inline">\(f_\#\mu\)</span> is a Gaussian measure on <span class="math inline">\(\mathbb{R}\)</span>. Necesarily</p>
<p>If we specifically look at the case where <span class="math inline">\(X\)</span> is a Hilbert space, more can be said about Gaussian measures on <span class="math inline">\(X\)</span>. Note that by the Riesz representation theorem, <span class="math inline">\(H\)</span> is canonically identified with its dual, so <span class="math inline">\(q\)</span> is identified with a unique bounded bilinear form on <span class="math inline">\(H\)</span>. Just like the corresponded outlined in fact (3) for the finite dimensional setting, there is the following correspondence.</p>
<p><strong>Theorem</strong>: <span class="citation" data-cites="Kuo">(<a href="#ref-Kuo" role="doc-biblioref">Kuo [1975]</a>)</span> There is a bijective correspondence between gaussian measures on <span class="math inline">\(X\)</span> and positive semi-definite, self adjoint, <a href="https://en.wikipedia.org/wiki/Trace_class">trace class</a> operators on <span class="math inline">\(X\)</span>. Specifically,</p>
<ul>
<li>For each Gaussian measure <span class="math inline">\(\mu\)</span> on <span class="math inline">\(X\)</span>, its covariance form <span class="math inline">\(q\)</span> is given by $q(f,g)=f, S_g$ for a unique positive semi-definite, self adjoint, trace class operator <span class="math inline">\(S_\mu\)</span>.</li>
<li>For each positive semi-definite, self adjoint, trace class operator <span class="math inline">\(S\)</span> on <span class="math inline">\(X\)</span>, there exists a unique mean <span class="math inline">\(0\)</span> Gaussian measure <span class="math inline">\(\mu_S\)</span> with covariance form <span class="math inline">\(q_S(f,g):=\langle f,S g\rangle_X\)</span>.</li>
</ul>
<p>The construction of <span class="math inline">\(\mu\)</span> from <span class="math inline">\(q_S\)</span> is given by an infinite dimensional analogue of <a href="https://en.wikipedia.org/wiki/Bochner%27s_theorem">Bochner’s Theorem</a> and <a href="https://en.wikipedia.org/wiki/Characteristic_function_(probability_theory)#Inversion_formula">Levy-Inversion</a>. The upshot of this result is that we can construct whole families of Gaussian measures on Hilbert spaces very easily whereas it can be difficult for general Banach spaces.</p>
</section>
<section id="cameron-martin-theorem-integration-by-parts" class="level2">
<h2 class="anchored" data-anchor-id="cameron-martin-theorem-integration-by-parts">Cameron-Martin Theorem &amp; Integration by Parts</h2>
<p>An infinite dimensional analogue of equation (4) would be useful for giving us an integration by parts analogue and related analytic techniques. These are frequently used (not always rigorously) in Quantum Field Theory and the study of Gaussian processes <span class="citation" data-cites="QFT">(<a href="#ref-QFT" role="doc-biblioref">Albeverio, Høegh-Krohn, and Mazzucchi [2008]</a>)</span>. The main theorem that answers this question is the <em>Cameron-Martin theorem</em> (see <span class="citation" data-cites="BogachevGM">(<a href="#ref-BogachevGM" role="doc-biblioref">Bogachev [1998]</a>)</span>, <span class="citation" data-cites="Kuo">(<a href="#ref-Kuo" role="doc-biblioref">Kuo [1975]</a>)</span>, or <span class="citation" data-cites="Stroock">(<a href="#ref-Stroock" role="doc-biblioref">Stroock [2023]</a>)</span> for a detailed exposition). Intuitively, this theorem says is that for almost every <span class="math inline">\(h\in X\)</span>, <span class="math inline">\(\mu_h\)</span> and <span class="math inline">\(\mu\)</span> are mutually singular, while for very particular choices of <span class="math inline">\(h\)</span> and analogue of equation (4) holds.</p>
<p>Now for the technical statement. Note that for any continuous linear functional <span class="math inline">\(f\in X^*\)</span>, <span class="math display">\[
\int_X|f(x)|^2 d\mu(x) = \int_\mathbb{R}x^2d(f_\#\mu)(x) &lt;\infty
\]</span> since <span class="math inline">\(f_\#\mu\)</span> is a Gaussian measure and <span class="math inline">\(|x|^2\)</span> is integrable w.r.t. any Gaussian measure. In particular, there is an inclusion <span class="math inline">\(X^*\hookrightarrow L^2(X,\mu)\)</span>. Considering <span class="math inline">\(X^*\)</span> as a subset of <span class="math inline">\(L^2(X,\mu)\)</span>, let the completion <span class="math inline">\(\overline{X^*}^{L^2(X,\mu)}\)</span> be denoted <span class="math inline">\(K\)</span>. Now define <span class="math display">\[
    H:=\{h\in X: \text{ the evaluation map }\phi_h:X^*\rightarrow \mathbb{R} \text{ given by } f\mapsto f(h) \text{ is continuous}\}
\]</span> By the <a href="https://en.wikipedia.org/wiki/Continuous_linear_extension">continuous linear extension theorem</a> it follows that for any <span class="math inline">\(h\in H\)</span>, <span class="math inline">\(\phi_h\)</span> extends to a continuous linear functional on <span class="math inline">\(K\)</span>, the <span class="math inline">\(L^2(X,\mu)\)</span> closure of <span class="math inline">\(X^*\)</span>. Since <span class="math inline">\(K\)</span> is a hilbert space with the <span class="math inline">\(L^2(X,\mu)\)</span> norm, it is identified with its dual. Thus we have a map <span class="math inline">\(T:H\rightarrow K\)</span> where <span class="math inline">\(T(h)\)</span> is characterized by the fact that for any <span class="math inline">\(f\in X^*\)</span>, <span class="math inline">\(q(Th,f)=f(h)\)</span>. One can prove that this is an isometry, hence it induces a complete inner product on <span class="math inline">\(H\)</span>, which we denote by <span class="math inline">\(\langle\cdot,\cdot \rangle_H\)</span>. We now have the language to state the following striking result.</p>
<p><strong>Theorem</strong> <em>(Cameron-Martin)</em>: Let <span class="math inline">\(\mu\)</span> be a Gaussian measure on a a separable Banach space <span class="math inline">\(X\)</span> with Cameron-Martin space <span class="math inline">\(H\)</span>. Then <span class="math inline">\(\mu(H)=0\)</span> and</p>
<ol type="1">
<li>If <span class="math inline">\(h\in H\)</span> then <span class="math inline">\(\mu_h &lt;&lt; \mu\)</span> and <span class="math display">\[
\frac{d\mu_h}{d\mu} = \exp\left\{-\frac{1}{2}\|h\|_H^2+\langle h,x\rangle\right\}
\]</span></li>
<li>If <span class="math inline">\(h\in X\setminus H\)</span> then <span class="math inline">\(\mu_h\)</span> and <span class="math inline">\(\mu\)</span> are mutually singular.</li>
</ol>
<p>This makes precise the intuitive statement that equation (4) fails for <span class="math inline">\(\mu\)</span> almost every <span class="math inline">\(h\)</span> For these pathological <span class="math inline">\(h\)</span>, there is no hope for an integration by parts formula or similar tools. For an explanation on the associated integration by parts formula (and why translation invariance leads to integration by parts) see <span class="citation" data-cites="driver">(<a href="#ref-driver" role="doc-biblioref">Driver 1991</a>)</span>.</p>
<p>The situation is analogous to have a measure on <span class="math inline">\(\mathbb{R}^2\)</span> which is a Gaussian measure on the <span class="math inline">\(x\)</span>-axis and zero elswhere. If we translate this measure along the <span class="math inline">\(x\)</span> direction, the resulting measure will be mutually absolutely continuous. If we translate this measure by any other direction, however, the two measures will be mutually singular.</p>



</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-QFT" class="csl-entry" role="listitem">
Albeverio, Sergio A., Raphael J. Høegh-Krohn, and Sonia Mazzucchi. [2008]. <em>Mathematical Theory of Feynman Path Integrals</em>. Lecture Notes in Mathematics. Springer Berlin, Heidelberg. <a href="https://doi.org/10.1007/978-3-540-76956-9">https://doi.org/10.1007/978-3-540-76956-9</a>.
</div>
<div id="ref-BogachevGM" class="csl-entry" role="listitem">
Bogachev, Vladimir I. [1998]. <em>Gaussian Measures</em>. Vol. 62. Mathematical Surveys and Monographs. Americal Mathematical Society.
</div>
<div id="ref-BogachevRef" class="csl-entry" role="listitem">
———. 2006. <em>Measure Theory</em>. Springer Berlin, Heidelberg.
</div>
<div id="ref-driver" class="csl-entry" role="listitem">
Driver, Bruce K. 1991. <span>“Heat Kernel Measures and Infinite Dimensional Analysis.”</span> <a href="https://mathweb.ucsd.edu/~bdriver/DRIVER/Preprints/driver-ihp02-2p.pdf">https://mathweb.ucsd.edu/~bdriver/DRIVER/Preprints/driver-ihp02-2p.pdf</a>.
</div>
<div id="ref-Eldredge" class="csl-entry" role="listitem">
Eldredge, Nathaniel. 2016. <span>“Analysis and Probability on Infinite-Dimensional Spaces.”</span> <a href="https://arxiv.org/abs/1607.03591">https://arxiv.org/abs/1607.03591</a>.
</div>
<div id="ref-Kuo" class="csl-entry" role="listitem">
Kuo, Hui-Sung. [1975]. <em>Gaussian Measures in Banach Spaces</em>. Lecture Notes in Mathematics. Springer Berlin, Heidelberg. <a href="https://doi.org/10.1007/BFb0082007">https://doi.org/10.1007/BFb0082007</a>.
</div>
<div id="ref-Stroock" class="csl-entry" role="listitem">
Stroock, Daniel W. [2023]. <em>Gaussian Measures in Finite and Infinite Dimensions</em>. Universitext. Springer, Cham. <a href="https://doi.org/10.1007/978-3-031-23122-3">https://doi.org/10.1007/978-3-031-23122-3</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/otwiki\.github\.io\/otwiki-main\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // default icon
          link.classList.add("external");
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>