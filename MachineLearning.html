<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="EF">

<title>Machine Learning and Optimal Transport – OT WIKI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">OT WIKI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Machine Learning and Optimal Transport</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>EF </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Optimal transport concepts applied to machine learning applications can also be referred to as computational Optimal Transport (OT). At its core, machine learning focuses on making comparisons between complex objects. To properly measure these similarities, a metric is needed, which is a distance function. Optimal transport is a natural tool in this case, as it is concerned with efficient distance functions (e.g.&nbsp;the Wasserstein metric).</p>
<p>In addition, optimal transport respects the underlying structure and geometry of a problem while providing a framework for comparing probability distributions. Optimal transport methods have received attention from researchers in fields as varied as economics, statistics, and quantum mechanics. The categories that applications of OT methods in a machine learning context can be divided into include learning, domain adaptation, Bayesian inference, and hypothesis testing<ref name="Kolouri">Kolouri, Soheil, Serim Park, Matthew Thorpe, Dejan Stepcey, Gustavo Rohde. Optimal Mass Transport: Signal Processing and Machine-Learning Applications. IEEE Signal Process Mag. 2017 Jul.&nbsp;34(4): 43-59.</ref>.</p>
<section id="learning-methods" class="level3">
<h3 class="anchored" data-anchor-id="learning-methods">Learning Methods</h3>
<p>These methods have used transport-based distances in a wide range of research contexts, ranging from language analysis to image recognition. To a certain extent, the geometry underlying optimal transport models helps to generate faster algorithms as well as establish data connections. Optimal transport models still have limitations, however, as some structure may not be captured. This structure can be described as either intrinsic or extrinsic. It is intrinsic if the distributions reflect structured objects (e.g.&nbsp;images with segments) and it can be characterized as extrinsic if there is additional information that creates structure (such as groupings) <ref name="Alvarez-Melis">Alvarez-Melis, David, Et al.&nbsp;Structured Optimal Transport. Proceedings of the 21st International Conference on Artificial Intelligence and Statistics (AISTATS) 2018, Lanzarote, Spain. PMLR: Volume 84. </ref>. The following are some types of models that fall into the learning methods in the OT category.</p>
<section id="graph-based-semi-supervised-learning" class="level4">
<h4 class="anchored" data-anchor-id="graph-based-semi-supervised-learning">Graph-based Semi-supervised Learning</h4>
<p>Graph-based semi-supervised learning is an effective approach for classification from a large variety of domains, including image and text classification. It is possible to use graph-based algorithms with this method, and the method is often useful for unlabeled data. To imagine what data is best analyzed by this type of model, consider a graph with multiple nodes. These graph nodes are usually associated with a simple label, like a real number. Now consider more complex node labels, such as probability distributions or histograms. A concrete example of this would be a set of traffic cameras distributed across a geographical area, each of which produces a histogram or a distribution of commuter traffic over a given period of time. Many other interesting research questions exhibit a similar structure (e.g.&nbsp;climate data, rankings of restaurants, etc.). Optimal transport-inspired methods have used the two-Wasserstein distance between distributions to analyze models of this type <ref name="Solomon">Solomon, J., et al.&nbsp;Wasserstein Propagation for Semi-Supervised Learning. Proceedings of the 31st International Conference on Machine Learning, Beijing, China, 2014. JMLR: W&amp;CP volume 32. Copy- right 2014.</ref> The work of Solomon, et. al.&nbsp;in this area led to additional insights by Gao, et. al, where Wassertstein propagation on graphs was used as the basis for a message-passing algorithm. This technique facilitated a generalization that could be applied to hypergraphs through Wasserstein barycenters <ref name="Gao"> Gao, Tingran, et al.&nbsp;Wasserstein Soft Label Propagation on Hypergraphs: Algorithm and Generalization Error Bounds. Univ. of Chicago. 2019 </ref>.</p>
</section>
<section id="generative-adversarial-networks-gan" class="level4">
<h4 class="anchored" data-anchor-id="generative-adversarial-networks-gan">Generative Adversarial Networks (GAN)</h4>
<p>A class of frameworks for machine learning developed in 2014 by Ian Goodfellow (Goodfellow). Machine learning frameworks where two neural networks are used compete against each other in a game-theoretic sense. If a GAN is trained on a given set of training data, it can produced a new set of data that is at the surface similar to the original set of data (for example, it can create new, similar images based on an initial training set of images). These techniques have been used in semi-supervised learning. They offer increased flexibility in use of the objective function, including the use of f-divergences and Jensen-Shannon <ref name="Arjovsky"> Arjovsky, Martin, et al.&nbsp;Wasserstein GAN. arXiv:1701.07875v3 [stat.ML] 6 Dec 2017</ref>.</p>
<section id="wasserstein-gan-wgan" class="level5">
<h5 class="anchored" data-anchor-id="wasserstein-gan-wgan">Wasserstein GAN (WGAN)</h5>
<p>This is classified as a type of tool for unsupervised learning, which uses a minimization of the distance between data distribution contained in the training set and the distribution of the observed data. In certain cases this produces a more stable training process. It minimizes an approximation of the earth mover (EM) distance. The optimization problem associated with the WGAN was shown to be sound by Arjovsky. This type of GAN reduces some of the problems associated with GAN approaches, including a reduction in the need to balance the training of the generator and the discriminator <ref name="Arjovsky">. The WGAN also estimates the EM distance in a continuous manner via training the discriminator <ref name="Arjovsky">. The following is an algorithm implementing the WGAN approach <ref name="Arjovsky">.</ref></ref></ref></p>
</section>
</section>
<section id="algorithm-wasserstein-generative-adversarial-networks-wgan" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-wasserstein-generative-adversarial-networks-wgan">Algorithm: Wasserstein Generative Adversarial Networks (WGAN)</h4>
<p>Require : <span class="math inline">\(\alpha\)</span> learning rate, <span class="math inline">\(c\)</span> clipping parameter, <span class="math inline">\(m\)</span> batch size, <span class="math inline">\(n_{\text {critic }}\)</span> number of iterations of critic per generator iteration. Require : <span class="math inline">\(w_{0},\)</span> initial critic parameters, <span class="math inline">\(\theta_{0},\)</span> initial generator’s parameters. 1: <strong>while</strong> <span class="math inline">\(\theta\)</span> has not converged <strong>do</strong> 2: <strong>for</strong> <span class="math inline">\(t=0, \ldots, n_{\text {critic }}\)</span> <strong>do</strong> 3: Sample <span class="math inline">\(\left\{x^{(i)}\right\}_{i=1}^{m} \sim \mathbb{P}_{r}\)</span> a batch from the real data. 4: Sample <span class="math inline">\(\left\{z^{(i)}\right\}_{i=1}^{m} \sim p(z)\)</span> a batch of prior samples. 5: <span class="math inline">\(g_{w} \leftarrow \nabla_{w}\left[\frac{1}{m} \sum_{i=1}^{m} f_{w}\left(x^{(i)}\right)-\frac{1}{m} \sum_{i=1}^{m} f_{w}\left(g_{\theta}\left(z^{(i)}\right)\right)\right]\)</span> 6: <span class="math inline">\(w \leftarrow w+\alpha \cdot \operatorname{RMSProp}\left(w, g_{w}\right)\)</span> 7: <span class="math inline">\(w \leftarrow \operatorname{clip}(w,-c, c)\)</span> 8: <strong>end for</strong> 9: Sample <span class="math inline">\(\left\{z^{(i)}\right\}_{i=1}^{m} \sim p(z)\)</span> a batch of prior samples. 10: <span class="math inline">\(g_{\theta} \leftarrow-\nabla_{\theta} \frac{1}{m} \sum_{i=1}^{m} f_{w}\left(g_{\theta}\left(z^{(i)}\right)\right)\)</span> 11: <span class="math inline">\(\theta \leftarrow \theta-\alpha \cdot \operatorname{RMSProp}\left(\theta, g_{\theta}\right)\)</span> 12: <strong>end while</strong></p>
<p>Recall that the EM distance is both continuous and differentiable, this implies that the critic should be trained to toward optimality. As the critic is trained more, the gradient (Wasserstein) becomes more reliable. The Wasserstein GAN can have problems due to the enforcement of the Lipschitz constraint the critic, which required weight clipping (reflected in algorithm) <ref name="Gulrajani"> Gulrajani, I., et al.&nbsp;Improved Training of Wasserstein GANs. arXiv:1704.00028v3 [cs.LG] 25 Dec 2017. </ref></p>
</section>
</section>
<section id="restricted-bolzman-machines-rbm" class="level3">
<h3 class="anchored" data-anchor-id="restricted-bolzman-machines-rbm">Restricted Bolzman Machines (RBM)</h3>
<p>Restricted Boltzman Machines (RBM) are probabilistic graphical models and can obtain hierarchical features at multiple levels. Originally created under the name “Harmonim” in 1986 by Smolensky, RBM can learn a probability distribution over a given set of inputs. These machines are able to learn complex and multi-scale distributions based on empirical data. The RBM generally has a layer of latent variables with a given probability distribution. This probability distribution is defined over a set of binary observed variables with a parameter that is to be learned.</p>
<p>Learning of model parameters is usually facilitated by Kullback-Lieber divergence (divergence from the training sample to the model). In research by Montavan, it is assumed that a metric can be established between observations <ref name="Montavon"> Montavon, G., Klaus-Robert Muller, Marco Cuturi. Wasserstein Training of Restricted Boltzmann Machines. 30th Conference on Neural Information Processing Systems (NIPS 2016)</ref>. This was used to define the Wasserstein distance between the training sample distribution that the distribution formed by the Boltzman machine.</p>
</section>
<section id="entropy-regularized-wasserstein-loss" class="level3">
<h3 class="anchored" data-anchor-id="entropy-regularized-wasserstein-loss">Entropy-regularized Wasserstein Loss</h3>
<p>This has been used for multi-label classification. It is characterized by a relaxation of the transport problem which addresses unnormalized measure. It does this by replacing the equality constraints with soft penalties with respect to KL-divergence.<ref name="Peyre">Peyre, Gabriel, and Marco Cuturi, “Computational Optimal Transport”, Github, https://optimaltransport.github.io/pdf/ComputationalOT.pdf.</ref></p>
</section>
<section id="domain-adaptation" class="level3">
<h3 class="anchored" data-anchor-id="domain-adaptation">Domain Adaptation</h3>
<p>In this case the goal is to learn about or extrapolate from one domain to another, often by finding domain-invariant representations <ref name="Courty"> Courty, Nicolas, et al.&nbsp;Optimal Transport for Domain Adaptation. IEEE Transactions on Pattern Analysis and Machine Intelligence, Vol. X, No.&nbsp;X, Jan XX. 2018 </ref> In cases where these sorts of models are useful the distributions are generally different but related. This is a technique that is often used to transfer information based on labelled data to unlabeled data. For example, in some cases the labels are available in the source domain, but the classification needs to be conducted on the target. If the classifier is trained on the source domain, the data will have performance deficiencies in the targeted domain <ref name="Flamary"> Flamary, R. Domain Adaptation with Optimal Transport: From Mapping to Learning with Joint Distribution </ref>.</p>
<p>By obtaining the best transportation plan connecting the probability distributions of source and target domains, estimates of learning samples are estimated. The transformation is non-linear and invertible. This allows for the use of a variety of machine learning methods that can be used on the transformed dataset. Regularized, unsupervised models have been used, as well as Joint Class Proportion and Optimal Transport (JCPOT) to address multi-source domain adaptation. <ref name="Peyre">The following is a summary of an algorithm implemented by Redko, et al:<ref name="Redko">Redko, I., et al.&nbsp;Optimal Transport for Multi-source Domain Adaptation under Target Shift. arXiv:1803.04899v1 [stat.ML] 13 Mar 2018 et al.&nbsp;</ref></ref></p>
<section id="algorithm-joint-class-proportion-and-optimal-jcpot" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-joint-class-proportion-and-optimal-jcpot">Algorithm: Joint Class Proportion and Optimal (JCPOT)</h4>
<p>1: <strong>Parameters:</strong> <span class="math inline">\(\epsilon,\)</span> maxIter, <span class="math inline">\(\forall k\left(\mathrm{C}^{(k)} and \lambda^{(k)}\right)\)</span> 2: <span class="math inline">\(cpt \leftarrow 0\)</span>, <span class="math inline">\(err \leftarrow \infty\)</span> 3: <span class="math inline">\(\zeta^{(k)} \leftarrow \exp \left(-\frac{\mathbf{C}^{(k)}}{\epsilon}\right), \quad \forall k\)</span> 4: <strong>while</strong> <span class="math inline">\(cpt\)</span> &lt; maxIter <strong>and</strong> <span class="math inline">\(err\)</span> &gt; threshold <strong>do</strong> 5: <span class="math inline">\(\zeta^{(k)} \leftarrow \operatorname{diag}\left(\frac{\mathbf{m}}{c(k) \mathbf{1}}\right) \zeta^{(k)}, \quad \forall k\)</span> 6: <span class="math inline">\(\mathbf{h}^{(c p t)} \leftarrow exp (\sum_{k=1}^{K} \lambda^{(k)} \log (\mathbf{D}_{1}^{(k)} \zeta^{(k)}1))\)</span> 7: <span class="math inline">\(\zeta^{(k)} \leftarrow \zeta^{(k)} \operatorname{diag}\left(\frac{\mathbf{D}_{2}^{(k)} \mathbf{h}}{\zeta^{(k)} \mathbf{1}}\right), \quad \forall k\)</span> 8: <span class="math inline">\(\operatorname{err} \leftarrow\left\|\mathbf{h}^{(c p t)}-\mathbf{h}^{(c p t-1)}\right\|_{2}\)</span> 9: <span class="math inline">\(\quad c p t \leftarrow c p t+1\)</span></p>
<p>This algorithm describes the optimization problem solved in Redko, et al which used operators defined such that proportions between the source and target domains are equal. A Wasserstein barycenter problem was used to achieve this <ref name="Redko"> <ref name="Benamou"> Benamou, Jean-David, Carlier, Guillaume, Cuturi, Marco, Nenna, Luca, &amp; Peyré, Gabriel. 2015. Iterative Bregman projections for regularized Transportation problems. SIAM Journal on Scientific Computing, 37(2), A1111–A1138</ref>.</ref></p>
</section>
</section>
</section>
<section id="bayesian-inference" class="level2">
<h2 class="anchored" data-anchor-id="bayesian-inference">Bayesian Inference</h2>
<p>An important aspect of Bayesian inference is calculating expectations given a posterior probability function. This creates a complicated problem, mainly because of multidimensional integrals. The method usually used to solve these problems is Monte Carlo Markov Chains, which in turn introduce complications (slow convergence to empirical expectation, lack of sample independence) <ref name="Kolouri">Kolouri, Soheil, Serim Park, Matthew Thorpe, Dejan Stepcey, Gustavo Rohde. Optimal Mass Transport: Signal Processing and Machine-Learning Applications. IEEE Signal Process Mag. 2017 Jul.&nbsp;34(4): 43-59.</ref>. The need for these complicated MCMC models was bypassed in the work of El Moselhy and Marzouk <ref name="El Moselhy">El Moselhy, Tarek A., Youssef M Marzouk. Bayesian Inference with Optimal Maps. Journal of Computational Physics 231(23). September 2011. </ref> In a transport based method, Bayesian inference was formulated in terms of optimal transport theory, and the existence and uniqueness of a measure-preserving map was established. The map was subsequently parametrized and via the solution of an optimization problem. This approach helps bypass many of the problems associated with the MCMC models.</p>
</section>
<section id="hypothesis-testing" class="level2">
<h2 class="anchored" data-anchor-id="hypothesis-testing">Hypothesis Testing</h2>
<p>There are many methods of hypothesis testing that connect to machine learning. This might be more colloquially described as “goodness-of-fit,” or a summary of how well the actual observed data fits the data predicted by a given model. The most common tests used in this context are the chi-square, Kolmogorov-Smirnov and the Anderson-Darling tests. These tests are generally based on some distance between probability laws <ref name="del Barrio">. As such, it is not surprising that del Barrio et al described tests of goodness of fit based on the <span class="math inline">\(L_2\)</span>-Wasserstein Distance <ref name="del Barrio">del Barrio E, Cuesta-Albertos JA, Matrán C, et al.&nbsp;Tests of goodness of fit based on the l_2-Wasserstein distance. The Annals of Statistics. 1999; 27(4):1230–1239 </ref>. The Wasserstein distance was also used (with an entropic smoothing) to investigate the connections between univariate (PP/QQ plots, ROC/ODC curves) and multivariate tests (energy statistics, kernel based maximum mean discrepancy) <ref name="Ramdas"> Ramdas, Aaditya, Nicolás García Trillos, and Marco Cuturi. On Wasserstein Two-Sample Testing and Related Families of Nonparametric Tests. Entropy 2017, 19(2), 47 </ref>.</ref></p>
</section>
<section id="additional-resources" class="level2">
<h2 class="anchored" data-anchor-id="additional-resources">Additional Resources</h2>
<p>Recent research on cutting edge topics relating to optimal transport applications to machine learning can be found at <a href="https://www.msri.org/workshops/928">MSRI Workshops</a>.</p>
<p>Tutorials on machine learning methods can be found at the following: <a href="https://remi.flamary.com/cours/tuto_otml.html">Optimal Transport for Machine Learning</a>.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p><references></references></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/otwiki\.github\.io\/otwiki-main\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>