<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Garo Sarajian, Charles Kulick">

<title>Wasserstein Barycenters and Applications in Image Processing – OT WIKI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">OT WIKI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Wasserstein Barycenters and Applications in Image Processing</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Garo Sarajian, Charles Kulick </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>In <a href="https://en.wikipedia.org/wiki/Transportation_theory_(mathematics)">optimal transport</a>, a Wasserstein barycenter <span class="citation" data-cites="Santambrogio_2015">(<a href="#ref-Santambrogio_2015" role="doc-biblioref">Santambrogio 2015</a>)</span> is a <a href="https://en.wikipedia.org/wiki/Probability_measure">probability measure</a> that represents a weighted average between several probability measures with regard to the Wasserstein distance. This generalizes the notions of <a href="https://en.wikipedia.org/wiki/Barycenter">physical barycenters</a> and <a href="https://en.wikipedia.org/wiki/Centroid">geometric centroids</a> to the domain of measures.</p>
<section id="wasserstein-barycenters" class="level1">
<h1>Wasserstein Barycenters</h1>
<section id="motivation" class="level2">
<h2 class="anchored" data-anchor-id="motivation">Motivation</h2>
<p>Barycenters in physics and geometry are points that represent a notion of a <a href="https://en.wikipedia.org/wiki/Mean">mean</a> of a number of objects. In astronomy, the barycenter is the center of mass of two or more objects that orbit each other, and in geometry, a centroid is the <a href="https://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of all the points in an object. Given countably many points <span class="math inline">\(\{x_i\}_{i \in I} \subseteq \mathbb{R}^n\)</span> and nonnegative weights <span class="math inline">\(\{\lambda_i\}_{i\in I}\)</span>, the weighted <span class="math inline">\(L^2\)</span> barycenter of the points is the unique point <span class="math inline">\(y \in \mathbb{R}^n\)</span> such that:</p>
<p><span class="math display">\[y = \arg \min_{y \in \mathbb{R}^n} \sum_{i \in I} \lambda_i \|y - x_i\|^2\]</span></p>
<p>Wasserstein barycenters capture this concept for probability measures by replacing the <a href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidean distance</a> with the <a href="https://en.wikipedia.org/wiki/Wasserstein_metric">Wasserstein distance</a> of two probability measures, <span class="math inline">\(W_2(\mu, \nu)\)</span>.</p>
</section>
<section id="definition" class="level2">
<h2 class="anchored" data-anchor-id="definition">Definition</h2>
<p>Let <span class="math inline">\(\Omega\)</span> be a <a href="https://en.wikipedia.org/wiki/Domain_(mathematical_analysis)">domain</a> and <span class="math inline">\(\mathcal{P}(\Omega)\)</span> be the set of probability measures on <span class="math inline">\(\Omega\)</span>. Given a collection of probability measures <span class="math inline">\(\{\mu_i \}_{i \in I}\)</span> and nonnegative weights <span class="math inline">\(\{\lambda_i\}_{i \in I}\)</span>, we define the Wasserstein barycenter of <span class="math inline">\(\{\mu_i\}_{i \in I}\)</span> as any probability measure <span class="math inline">\(\mu\)</span> that minimizes the functional:</p>
<p><span class="math display">\[\sum_{i \in I} \lambda_i W_2( \mu_i, \mu)^2\]</span></p>
<p>over the space <span class="math inline">\(\mu \in \mathcal{P}(\Omega)\)</span>. Here <span class="math inline">\(W_2\)</span> denotes the <span class="math inline">\(2\)</span>-Wasserstein distance, which may be replaced with the <span class="math inline">\(p\)</span>-Wasserstein distance, <span class="math inline">\(W_p\)</span>, though this is less common.</p>
<p>This minimization problem was originally introduced by Agueh and Carlier <span class="citation" data-cites="Martial_2011">(<a href="#ref-Martial_2011" role="doc-biblioref">Agueh and Carlier 2011</a>)</span>, who also proposed an alternative formulation of the problem above when there are finitely many measures <span class="math inline">\(\{\mu_i\}_{i = 1}^n\)</span>. Instead of considering the minimum over all probability measures <span class="math inline">\(\mu \in \mathcal{P}(\Omega)\)</span>, one can equivalently consider the optimization problem over all multi-marginal transport plans <span class="math inline">\(\gamma \in \mathcal{P}(\Omega^{n+1})\)</span> whose <a href="https://en.wikipedia.org/wiki/Pushforward_measure">push forwards</a> satisfy <span class="math inline">\((\pi_i)_{\#} \gamma = \mu_i\)</span> for <span class="math inline">\(i \in \{1, \ldots, n\}\)</span> and <span class="math inline">\((\pi_0)_{\#} \gamma = \mu\)</span> for some unspecified probability measure <span class="math inline">\(\mu\)</span>. The problem then tries to minimize:</p>
<p><span class="math display">\[\int \left ( \sum_{i = 1}^N \lambda_i \| x_i - x_0 \|^2 \right ) d \gamma\]</span></p>
</section>
<section id="existence-and-uniqueness" class="level2">
<h2 class="anchored" data-anchor-id="existence-and-uniqueness">Existence and Uniqueness</h2>
<p>We consider the Wasserstein barycenter minimization problem for finitely many given measures <span class="math inline">\(\{\mu_i\}_{i=1}^n \subseteq \mathcal{P}_2(\mathbb{R}^d)\)</span> and nonnegative weights <span class="math inline">\(\lambda_i \geq 0\)</span>:</p>
<p><span class="math display">\[\inf_{\mu \in \mathcal{P}_2(\mathbb{R}^d)} \sum_{i=1}^n \lambda_i W_2(\mu_i, \mu)\]</span></p>
<p>Agueh and Carlier <span class="citation" data-cites="Martial_2011">(<a href="#ref-Martial_2011" role="doc-biblioref">Agueh and Carlier 2011</a>)</span> prove that, if at least one <span class="math inline">\(\mu_i\)</span> is <a href="https://en.wikipedia.org/wiki/Absolute_continuity">absolutely continuous</a> with Lebesgue measure, the Wasserstein barycenter <span class="math inline">\(\mu\)</span> exists and is unique, and is given by <span class="math inline">\(\mu = \nabla \phi_i \# \mu_i\)</span> where <span class="math inline">\(\phi_i\)</span> is a convex potential.</p>
<p>Furthermore, if all <span class="math inline">\(\mu_i\)</span> are absolutely continuous with Lebesgue measure, then the following are equivalent:</p>
<ul>
<li><p><span class="math inline">\(\mu\)</span> is the Wasserstein barycenter</p></li>
<li><p><span class="math inline">\(\mu = \nabla \phi_i \# \mu_i\)</span> for all <span class="math inline">\(i\)</span>, where <span class="math inline">\(\phi_i\)</span> is a convex potential</p></li>
<li><p>There exist convex potentials <span class="math inline">\(\psi_i\)</span> such that <span class="math inline">\(\nabla \psi_i\)</span> is the <a href="https://en.wikipedia.org/wiki/Polar_factorization_theorem">Brenier’s Theorem</a> transport map from <span class="math inline">\(\mu_i \rightarrow \mu\)</span> and a constant <span class="math inline">\(C\)</span> such that, for all <span class="math inline">\(y \in \mathbb{R}^d\)</span> with equality <span class="math inline">\(\mu\)</span>-almost everywhere:</p></li>
</ul>
<p><span class="math display">\[\sum_{i=1}^n \lambda_i \psi_i^*(y) \leq C + \frac{\|y\|^2}{2}\]</span></p>
</section>
</section>
<section id="examples" class="level1">
<h1>Examples</h1>
<section id="one-dimensional-measures" class="level2">
<h2 class="anchored" data-anchor-id="one-dimensional-measures">One Dimensional Measures</h2>
<p>Let <span class="math inline">\(\{\mu_i\}_{i=1}^n \subseteq \mathcal{P}_2(\mathbb{R})\)</span> be nonatomic probability measures and <span class="math inline">\(\{\lambda_i\}_{i=1}^n\)</span> weights such that <span class="math inline">\(\lambda_i &gt; 0\)</span> for all <span class="math inline">\(i\)</span> and <span class="math inline">\(\sum_{i=1}^n \lambda_i = 1\)</span>.</p>
<p>Then the Wasserstein barycenter <span class="math inline">\(\mu\)</span> is given explicitly by:</p>
<p><span class="math display">\[\mu = \left( \sum_{i=1}^n \lambda_i T_i \right) \# \mu_1\]</span> where <span class="math inline">\(T_i\)</span> is the transport map <span class="math inline">\(\mu_1 \rightarrow \mu_i\)</span> from Bernier’s Theorem. <span class="citation" data-cites="Martial_2011">(<a href="#ref-Martial_2011" role="doc-biblioref">Agueh and Carlier 2011</a>)</span></p>
</section>
<section id="computational-solution" class="level2">
<h2 class="anchored" data-anchor-id="computational-solution">Computational Solution</h2>
<p>If all of the considered measures <span class="math inline">\(\{\mu_i\}_{i=1}^n\)</span> are known to be finitely supported, computing the Wasserstein barycenter reduces to a problem in <a href="https://en.wikipedia.org/wiki/Linear_programming">linear programming</a> <span class="citation" data-cites="Gabriel_2019">(<a href="#ref-Gabriel_2019" role="doc-biblioref">Peyré and Cuturi 2019</a>)</span>. This is often the case for measures of interest in computational problems. The most common approach to computing Wasserstein barycenters is through <a href="https://www.otwiki.xyz/wiki/Sinkhorn%27s_Algorithm">Sinkhorn’s algorithm</a> with entropic regularization, illustrated below.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./wasserstein_barycenter_animation_updated.gif" class="img-fluid figure-img" style="width:90.0%"></p>
<figcaption>An example of Wasserstein barycenter computation between two Gaussians over <span class="math inline">\(\mathbb{R}\)</span>, as weights <span class="math inline">\(\lambda_1 + \lambda_2 = 1\)</span> change through the interval <span class="math inline">\((0,1)\)</span>. Gaussian 1 (red) has has <span class="math inline">\(\mu = -2.5, \sigma=1\)</span> while Gaussian 2 (blue) has <span class="math inline">\(\mu=3, \sigma=1.5\)</span>. The true Wasserstein barycenter (dotted black) is easily computed, as both measures are in <span class="math inline">\(\mathcal{P}_2(\mathbb{R})\)</span> for which an explicit formula is available as discussed above. The computed Wasserstein barycenter (green) is yielded through Sinkhorn iterations with entropic regularization. Note that the general shape of the measure is accurate, with some smoothing issues alleviated partially through the regularization. The arithmetic weighted mean of the distributions is included for comparison (dashed purple).</figcaption>
</figure>
</div>
</section>
<section id="k-means-connection" class="level2">
<h2 class="anchored" data-anchor-id="k-means-connection">K-Means Connection</h2>
<p>When the family of measures <span class="math inline">\(\{\mu_i\}_{i \in I}\)</span> consists of exactly one finitely supported measure <span class="math inline">\(\mu_1\)</span> and we restrict the minimization problem solution space to exclusively <span class="math inline">\(\mu\)</span> which are finitely supported probability measures whose supports have at most <span class="math inline">\(k\)</span> points, the problem of finding the Wasserstein barycenter is equivalent to the <a href="https://en.wikipedia.org/wiki/K-means_clustering"><span class="math inline">\(k\)</span>-means</a> clustering problem.</p>
</section>
</section>
<section id="applications" class="level1">
<h1>Applications</h1>
<section id="barycenters-in-image-processing" class="level2">
<h2 class="anchored" data-anchor-id="barycenters-in-image-processing">Barycenters in Image Processing</h2>
<p>Barycenters have several applications in <a href="https://en.wikipedia.org/wiki/Digital_image_processing">image processing</a>. A core example <span class="citation" data-cites="Sebastian_2018">(<a href="#ref-Sebastian_2018" role="doc-biblioref">Claici, Chien, and Solomon 2018</a>)</span> arises in <a href="https://en.wikipedia.org/wiki/Handwriting_recognition">handwriting recognition</a>. It is often useful to have a reference image of an expected letter, but simply taking the pixel-by-pixel Euclidean average fails to capture the geometric information of the letter. If the images are treated as probability distributions with pixel values as magnitudes, the Wasserstein barycenter provides a much more meaningful expected letter. We illustrate this application through the classical <a href="https://en.wikipedia.org/wiki/MNIST_database">MNIST dataset</a>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./mnist_digit_8_samples.png" class="img-fluid figure-img" style="width:90.0%"></p>
<figcaption>Some examples of the digit 8 sampled from the MNIST dataset. Images are grayscale, and interpreted as probability distributions for the Wasserstein barycenter calculation.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./mnist_digit_8_comparison.png" class="img-fluid figure-img" style="width:90.0%"></p>
<figcaption>The Wasserstein barycenter (left) versus the arithmetic mean (right) of the sampled images above. Note the relatively severe distortion of the arithmetic mean, with many artifacts present from the multiple angles and styles of the digit, while the Wasserstein barycenter is still recognizably the desired digit with relatively little artifacting.</figcaption>
</figure>
</div>
<p>Another core image processing application is image interpolation. Wasserstein barycenters can be used to interpolate between two or more images in a meaningful way <span class="citation" data-cites="Santambrogio_2015">(<a href="#ref-Santambrogio_2015" role="doc-biblioref">Santambrogio 2015</a>)</span>. For example, suppose we are given two images from the MNIST dataset. While taking an average of pixel values would result in an overlapped figure of the two digits in grayscale, there would be very little meaningful semantic information to extract from the image. By computing the Wasserstein barycenter for pairs of weights <span class="math inline">\(\lambda_1 + \lambda_2 = 1\)</span> and changing these weights in the interval <span class="math inline">\((0,1)\)</span>, we can interpolate smoothly between these two images and watch the transport action, as below. Similar ideas can be applied to enhance the contrast of an image.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./mnist_barycenter_3_to_8_animation.gif" class="img-fluid figure-img" style="width:90.0%"></p>
<figcaption>A random digit 3 (left) and a random digit 8 (right) from the MNIST dataset. The Wasserstein barycenter (center) of these two images is computed for weights <span class="math inline">\(\lambda_1, \lambda_2\)</span> ranging in <span class="math inline">\((0,1)\)</span> for a smooth interpolation of these images.</figcaption>
</figure>
</div>
</section>
<section id="model-ensembling" class="level2">
<h2 class="anchored" data-anchor-id="model-ensembling">Model Ensembling</h2>
<p><a href="https://en.wikipedia.org/wiki/Ensemble_learning">Model ensembling</a> is a popular machine learning technique for improving accuracy in difficult learning tasks. Typically this involves training several sub-models on the same task, and then averaging their predictions in a semantically meaningful way to yield one true prediction model, which often has higher accuracy than any singular sub-model.</p>
<p>The Wasserstein barycenter provides one approach to accomplishing this core task <span class="citation" data-cites="Pierre_2019">(<a href="#ref-Pierre_2019" role="doc-biblioref">Dognin et al. 2019</a>)</span> while maintaining a high level of semantic meaning. Sub-models are interpreted as defining a distribution over some label space, rather than a singular output, and the ensemble model defines the Wasserstein barycenter of these distributions over label space. This allows for interesting analysis of the entire ensemble distribution, potentially useful in hard classification tasks.</p>
</section>
</section>
<section id="generalizations" class="level1">
<h1>Generalizations</h1>
<p>Allowing negative barycenter weights yields a generalized minimization problem:</p>
<p><span class="math display">\[\inf_{\mu \in \mathcal{P}_2(X)} \sum_{i=1}^n \lambda_i W_2(\mu_i, \mu)^2 \]</span> where the constraint on <span class="math inline">\(\lambda_i\)</span> is only <span class="math inline">\(\sum_{i=1}^n \lambda_i &gt; 0\)</span>.</p>
<p>In recent analysis <span class="citation" data-cites="tornabene2024generalizedwassersteinbarycenters">(<a href="#ref-tornabene2024generalizedwassersteinbarycenters" role="doc-biblioref">Tornabene, Veneroni, and Savaré 2024</a>)</span>, this more general formulation is considered over a separable Hilbert space <span class="math inline">\(X\)</span>. Let <span class="math inline">\(n \geq 2\)</span>, and <span class="math inline">\(\{\mu_i\}_{i=1}^n \subseteq \mathcal{P}_2(X)\)</span> be given probability measures and <span class="math inline">\(\{\lambda_i\}_{i=1}^n\)</span> be real weights such that <span class="math inline">\(\sum_{i=1}^n \lambda_i &gt; 0\)</span>. Note that individual weights can be negative, provided the total sum fulfills this condition. Then a solution <span class="math inline">\(\mu\)</span> exists:</p>
<p><span class="math display">\[\mu = \arg \min_{\mu \in \mathcal{P}_2(X)} \sum_{i=1}^n \lambda_i W_2(\mu_i, \mu)^2\]</span> Note that uniqueness does not hold in general, but if there exists exactly one <span class="math inline">\(k\)</span> with <span class="math inline">\(1 \leq k \leq n\)</span> such that <span class="math inline">\(\lambda_k &gt; 0\)</span> and for all <span class="math inline">\(i \neq k\)</span>, <span class="math inline">\(\lambda_i &lt; 0\)</span>, we further have that <span class="math inline">\(\mu\)</span> is unique.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Martial_2011" class="csl-entry" role="listitem">
Agueh, Martial, and Guillaume Carlier. 2011. <span>“Barycenters in the Wasserstein Space.”</span> <em>SIAM Journal on Mathematical Analysis</em> 43 (2): 904–24. <a href="https://doi.org/10.1137/100805741">https://doi.org/10.1137/100805741</a>.
</div>
<div id="ref-Sebastian_2018" class="csl-entry" role="listitem">
Claici, Sebastian, Edward Chien, and Justin Solomon. 2018. <span>“Stochastic Wasserstein Barycenters.”</span> In <em>Proceedings of the 35th International Conference on Machine Learning</em>, edited by Jennifer Dy and Andreas Krause, 80:999–1008. Proceedings of Machine Learning Research. PMLR. <a href="https://proceedings.mlr.press/v80/claici18a.html">https://proceedings.mlr.press/v80/claici18a.html</a>.
</div>
<div id="ref-Pierre_2019" class="csl-entry" role="listitem">
Dognin, Pierre, Igor Melnyk, Youssef Mroueh, Jerret Ross, Cı́cero Nogueira dos Santos, and Tom Sercu. 2019. <span>“Wasserstein Barycenter Model Ensembling.”</span> <em>CoRR</em> abs/1902.04999. <a href="http://arxiv.org/abs/1902.04999">http://arxiv.org/abs/1902.04999</a>.
</div>
<div id="ref-Gabriel_2019" class="csl-entry" role="listitem">
Peyré, Gabriel, and Marco Cuturi. 2019. Vol. 11. <a href="https://doi.org/10.1561/2200000073">https://doi.org/10.1561/2200000073</a>.
</div>
<div id="ref-Santambrogio_2015" class="csl-entry" role="listitem">
Santambrogio, Filippo. 2015. In <em>Optimal Transport for Applied Mathematicians</em>. Birkhäuser Cham. <a href="https://doi.org/10.1007/978-3-319-20828-2">https://doi.org/10.1007/978-3-319-20828-2</a>.
</div>
<div id="ref-tornabene2024generalizedwassersteinbarycenters" class="csl-entry" role="listitem">
Tornabene, Francesco, Marco Veneroni, and Giuseppe Savaré. 2024. <span>“Generalized Wasserstein Barycenters.”</span> <a href="https://arxiv.org/abs/2411.06838">https://arxiv.org/abs/2411.06838</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/otwiki\.xyz");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>